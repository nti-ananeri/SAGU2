<?php
/**
 *
 * This file handles the connection and actions for finIncomeForecast table
 *
 * @author Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 *         and Eduardo Beal Miglioransa [eduardo@solis.coop.br]
 *
 * @maintainer: William Prigol Lopes [william@solis.coop.br]
 *
 * $version: $Id$
 *
 * \b Maintainers \n
 * Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 * Daniel Afonso Heisler [daniel@solis.coop.br]
 * Eduardo Beal Miglioransa [eduardo@solis.coop.br]
 * Jamiel Spezia [jamiel@solis.coop.br]
 * Rafael Luís Spengler [rafael@solis.coop.br]
 * William Prigol Lopes [william@solis.coop.br]
 * Eduardo Beal Miglioransa [eduardo@solis.coop.br]
 * 
 * @since
 * Class created on 06/12/2005
 *
 * \b @organization \n
 * SOLIS - Cooperativa de Soluções Livres \n
 * The Sagu2 development team
 *
 * \b Copyleft \n
 * Copyleft (L) 2005 - SOLIS - Cooperativa de Soluções Livres \n
 *
 * \b License \n
 * Licensed under GPL (for further details read the COPYING file or http://www.gnu.org/copyleft/gpl.html )
 *
 * \b History \n
 * See history in CVS repository: http://sagu.solis.coop.br   
 *
 **/

/**
 * Class to manipulate the finIncomeForecast table
 **/
class BusinessFinanceBusIncomeForecast extends MBusiness
{
    /* the $db attribute must be public since it is accessed by other business (academic/BusContractLock.class:201) */
    public $db;
    public $generationData;

    /**
     * Class constructor to instantiate a new database connection. This makes possible to use transactions
     **/
    function BusinessFinanceBusIncomeForecast()
    {
        $this->db = $this->getDatabase();
    }

    /**
     * Make a connection to the database
     * 
     * @param $module (string): The module whose database we should connect. If null, the actual module database is connected.
     *
     * @return (object): A MIOLO Database connection
     **/
    public function getDatabase($dbname=null)
    {
        $MIOLO = MIOLO::getInstance();
        $MIOLO->getClass('basic','sagu');
        $module = is_null($module) ? 'finance' : $module;

        return $MIOLO->getDatabase($module);

    }

    /**
     * List all records from the table handled by the class
     *
     * @param: None
     *
     * @returns (array): Return an array with the entire table
     *
     **/
    public function listIncomeForecast()
    {
    }

    /**
     * Return a specific record from the database
     *
     * @param $incomeForecastId (integer): Primary key of the record to be retrieved
     *
     * @return (object): Return an object of the type handled by the class
     *
     **/
    public function getIncomeForecast($incomeForecastId)
    {
        $sql = '    SELECT A.incomeForecastId,
                           C.personId,
                           getPersonName(C.personId),
                           A.contractId,
                           C.courseId,
                           C.courseVersion,
                           G.name,
                           A.operationId,
                           D.description,
                           A.accountSchemeId,
                           E.description,
                           A.costCenterId,
                           F.description,
                           A.value,
                           A.comments,
                           TO_CHAR(A.recordDate,\'' . MASK_DATE . '\'),
                           TO_CHAR(A.maturityDate,\'' . MASK_DATE . '\'),
                           A.isAccounted,
                           A.isProcessed,
                           A.isSupressed,
                           A.userName,
                           TO_CHAR(A.dateTime,\'' . MASK_TIMESTAMP . '\')
                      FROM finIncomeForecast A
                INNER JOIN acdContract C
                     USING (contractId)
                INNER JOIN finOperation D
                     USING (operationId)
                INNER JOIN accAccountScheme E
                     USING (accountSchemeId)
                INNER JOIN accCostCenter F
                     USING (costCenterId)
                INNER JOIN acdCourse G
                     USING (courseId)
                     WHERE A.incomeForecastId = ?';

        $result = $this->db->query(SAGU::prepare($sql,$incomeForecastId));

        $incomeForecast = new FinIncomeForecast();

        list ( $incomeForecast->incomeForecastId,
               $incomeForecast->contractPersonId,
               $incomeForecast->contractPersonName,
               $incomeForecast->contractId,
               $incomeForecast->contractCourseId,
               $incomeForecast->contractCourseVersion,
               $incomeForecast->contractCourseName,
               $incomeForecast->operationId,
               $incomeForecast->operationDescription,
               $incomeForecast->accountSchemeId,
               $incomeForecast->accountSchemeDescription,
               $incomeForecast->costCenterId,
               $incomeForecast->costCenterDescription,
               $incomeForecast->value,
               $incomeForecast->comments,
               $incomeForecast->recordDate,
               $incomeForecast->maturityDate,
               $incomeForecast->isAccounted,
               $incomeForecast->isProcessed,
               $incomeForecast->isSupressed,
               $incomeForecast->userName,
               $incomeForecast->dateTime ) = $result[0];
        return $incomeForecast; 
    }

    /**
     * Do a search on the database table handled by the class
     *
     * @param $filters (object): Search filters
     *
     * @return (array): An array containing the search results
     **/
    public function searchIncomeForecast($data)
    {
        $sql = 'SELECT A.incomeForecastId,
                       A.periodId,
                       A.contractId,
                       A.operationId,
                       A.accountSchemeId,
                       A.costCenterId,
                       A.value,
                       A.comments,
                       TO_CHAR(A.recordDate,\'' . MASK_DATE . '\'),
                       TO_CHAR(A.maturityDate,\'' . MASK_DATE . '\'),
                       A.isAccounted,
                       A.isProcessed,
                       A.isSupressed
                  FROM finIncomeForecast A,
                       acdPeriod B,
                       acdContract C,
                       finOperation D,
                       accAccountScheme E,
                       accCostCenter F
                 WHERE B.periodId        = A.periodId
                   AND C.contractId      = A.contractId
                   AND D.operationId     = A.operationId
                   AND E.accountSchemeId = A.accountSchemeId
                   AND F.costCenterId    = A.costCenterId';

        $where = '';
        unset($args);
        if ( strlen((string)$data->incomeForecastId) > 0 )
        {
            $where .= '    AND   A.incomeForecastId = ?';
            $args[] = $data->incomeForecastId;
        }
        if ( strlen((string)$data->periodId) > 0 )
        {
            $where .= '    AND   A.periodId ILIKE ?';
            $args[] = $data->periodId;
        }
        if ( strlen((string)$data->contractId) > 0 )
        {
            $where .= '    AND   A.contractId = ?';
            $args[] = $data->contractId;
        }
        if ( strlen((string)$data->personId) > 0 )
        {
            $where .= '    AND   C.personId = ?';
            $args[] = $data->personId;
        }
        if ( strlen((string)$data->operationId) > 0 )
        {
            $where .= '    AND   A.operationId = ?';
            $args[] = $data->operationId;
        }
        if ( strlen((string)$data->accountSchemeId) > 0 )
        {
            $where .= '    AND   A.accountSchemeId = ?';
            $args[] = $data->accountSchemeId;
        }
        if ( strlen((string)$data->costCenterId) > 0 )
        {
            $where .= '    AND   A.costCenterId = ?';
            $args[] = $data->costCenterId;
        }

        if ( strlen((string)$where) > 0 )
        {
            $sql .= $where .
                    ' ORDER BY A.recordDate DESC,
                               A.incomeForecastId';

            $result = $this->db->query(SAGU::prepare($sql,$args));
        }

        return $result;
    }

    /**
     * Insert a new record
     *
     * @param $data (object): An object of the type handled by the class
     *
     * @return True if succed, otherwise False
     *
     **/
    public function insertIncomeForecast($data)
    {
        $sql = 'SELECT NEXTVAL(\'seq_incomeforecastid\')';

        $retVal = $this->db->query($sql);

        unset($incomeForecastId);
        if ( isset($retVal) )
        {
            $incomeForecastId = $retVal[0][0];
            $sql = 'INSERT INTO finIncomeForecast
                                (incomeForecastId,
                                 contractId,
                                 operationId,
                                 accountSchemeId,
                                 costCenterId,
                                 value,
                                 comments,       
                                 recordDate,
                                 maturityDate,
                                 isAccounted,
                                 isProcessed,
                                 isGenerated ';

            if (strlen((string)$data->enrollSummaryId)>0)
            {
                $sql.= ', enrollSummaryId ';
                
            }
            $sql.='          )
                         VALUES (?,?,?,?,?,?, 
                                 ?, ';
            if ( is_null($data->recordDate) )
            {
                $sql .= 'now(),';
            }
            else
            {
                $sql .= 'TO_DATE(?,\'' . MASK_DATE . '\'), ';
                $recordDate = $data->recordDate;
            }


            $sql .=   '        TO_DATE(?,\'' . MASK_DATE . '\'),
                               FALSE, FALSE, ? ';

            if (strlen((string)$data->enrollSummaryId)>0)
            {
                $sql.=', ? ';
            }               

            $sql.= ')';

            $args = array($incomeForecastId,
                          $data->contractId,
                          $data->operationId,
                          $data->accountSchemeId,
                          $data->costCenterId,
                          $data->value,
                          $data->comments);

            if ( strlen((string)$data->recordDate)>0)
            {
                $args[] = $data->recordDate;
            }

            $args[] =  $data->maturityDate;
            $args[] =  $data->isGenerated;
            if (strlen((string)$data->enrollSummaryId)>0)
            {
                $args[] =  $data->enrollSummaryId;
            }
            if ( ! $this->db->execute(SAGU::prepare($sql, $args)) )
            {
                unset($incomeForecastId);
            }
        }
        return $incomeForecastId;
    }

    /**
     * Update data from a specific record
     *
     * @param $data (object): Data which will replace the old record data
     *
     * @return (boolean): True if succeed, otherwise False
     *
     **/
    public function updateIncomeForecast($data)
    {
        $sql = 'UPDATE finIncomeForecast
                   SET contractId        = ?,
                       operationId       = ?,
                       accountSchemeId   = ?,
                       costCenterId      = ?,
                       value             = ?,
                       comments          = ?,
                       recordDate        = TO_DATE(?,\'' . MASK_DATE . '\'),
                       maturityDate      = TO_DATE(?,\'' . MASK_DATE . '\'),
                       isProcessed       = ?,
                       isSupressed       = ?
                 WHERE incomeForecastId  = ?';

        $args = array($data->contractId,
                      $data->operationId,
                      $data->accountSchemeId,
                      $data->costCenterId,
                      $data->value,
                      $data->comments,
                      $data->recordDate,
                      $data->maturityDate,
                      $data->isProcessed,
                      $data->isSupressed,
                      $data->incomeForecastId);
        
        $sqls = SAGU::prepare($sql, $args);

        for ( $i=0; $i<count($sqls); $i++ )
        {
            $result = $this->db->execute($sqls[$i]);
        }

        return $result;
    }

    /**
     * Delete a record
     *
     * @param $paymentPlaceId (string): Primary key for deletion
     *
     * @return (boolean): True if succeed, otherwise False
     *
     **/
    public function deleteIncomeForecast($incomeForecastId)
    {
        $sql = 'DELETE FROM finIncomeForecast
                      WHERE incomeForecastId = ?';

        $args = array($incomeForecastId);
        $result = $this->db->execute(SAGU::prepare($sql,$args));

        return $result;
    }

    /**
     * $year, $month and $day composes the base date, which will
     * be increased by $monthsToAdd months
     *
     * @param $year (integer): The base date year
     * @param $month (integer): The base date month
     * @param $day (integer): The base date day
     * @param $monthsToAdd (integer): The number of months to add to the current date
     *
     * @return (object): Return an object containing 3 attributes (year, month and day) representing the newly defined date
     **/
    public function addMonths($year, $month, $day, $monthsToAdd)
    {
        $month += $monthsToAdd;

        $year += (int)(($month-1) / 12);
        $month = $month - (12 * (int)(($month-1) / 12));

        // Define an array containing the number of
        // days for each month of the year
        $monthDays[1] = 31;
        // check if year is bissextile, that is,
        // if ( $year is even dibisible by 4 ) OR ( $year ends with '00' and is even divible by 400 )
        if ( ($year % 4 == 0) || 
             ( (substr($year,2,2) == '00') && ($year % 400 == 0) ) )
        {
            $monthDays[2] = 29;
        }
        else
        {
            $monthDays[2] = 28;
        }
        $monthDays[3]  = 31;
        $monthDays[4]  = 30;
        $monthDays[5]  = 31;
        $monthDays[6]  = 30;
        $monthDays[7]  = 31;
        $monthDays[8]  = 31;
        $monthDays[9]  = 30;
        $monthDays[10] = 31;
        $monthDays[11] = 30;
        $monthDays[12] = 31;

        if ( $day > $monthDays[$month] )
        {
            $day = $monthDays[$month];
        }

        $obj->year  = $year;
        $obj->month = $month;
        $obj->day   = $day;

        return $obj;
    }

    /**
     * Calculate the value of each parcel. To avoid loss of cents due to rounding,
     * the following algorithm is used:
     *
     * - first parcel is parcel 1
     * - last parcel is parcel n
     *
     * parcel(2) = totalValue / parcelsNumber
     * parcel(3) = totalValue / parcelsNumber
     * parcel(4) = totalValue / parcelsNumber
     * ...
     * parcel(n) = totalValue / parcelsNumber
     *
     * parcel(1) = totalValue - (parcel(2) + parce(3) + parcel(4) + ... + parcel(n))
     *
     * @param $totalValue (float): Total value to be parcelled
     * @param $parcelsNumber (int): The number of parcels the value will be divided
     *
     * @return Return an array containing one parcel on each position.
     *
     **/
    public function getParcelsValues($totalValue, $parcelsNumber)
    {

        // Calculate the value of each parcel
        $totalValue = SAGU::formatNumber($totalValue);
        $value      = SAGU::calcNumber($totalValue.' / '.SAGU::formatNumber($parcelsNumber));

        for ( $parcelNumber = 1; $parcelNumber < $parcelsNumber; $parcelNumber++ )
        {
            $sql .= $value . ' + ';
            $parcelsValues[$parcelNumber] = SAGU::formatNumber($value);
        }

        if ( $parcelsNumber > 1 )
        {
            $value = SAGU::calcNumber($totalValue .' - (' . substr($sql, 0, strlen((string)$sql) - 3) . ') ', true);
            $parcelsValues[0] = $value;
        }
        elseif ( $parcelsNumber == 1 )
        {
            $parcelsValues[0] = $totalValue;
        }
        return $parcelsValues;
    }

    /**
     * Get the operation id to be used when some value must be
     * calculated based on the enroll total value
     *
     * @param $learningPeriodId (int): The learning period the query will be made
     *
     * @return Return the operation id, if found. Otherwise, return NULL
     *
     **/
    public function getDefaultOperationIdForEnroll($learningPeriodId)
    {
        // Get the operation id to know what value to consider when
        // calculating taxes
        $sql = 'SELECT B.operationId
                  FROM acdLearningPeriod A
            INNER JOIN finPolicy B
                    ON (B.policyId = A.policyId)
                 WHERE A.learningPeriodId = ?';

        $res = $this->db->query(SAGU::prepare($sql, $learningPeriodId));

        return $res[0][0];
    }

    /**
     * See if the specified contract belongs to a freshman or not
     *
     * @param $contractId (int): The contract to query
     *
     * @return TRUE if the contract belongs to a freshman. Otherwise, FALSE.
     *
     **/
    public function isFreshman($contractId)
    {
        $sql = 'SELECT COUNT(DISTINCT B.learningPeriodId) > 0 AS isFreshMan
                  FROM acdEnroll A
            INNER JOIN acdGroup B
                    ON (B.groupId = a.groupId)
                 WHERE A.contractId = ?';

        $res = $this->db->query(SAGU::prepare($sql, $contractId));

        return ($res[0][0] == DB_TRUE);
    }


  /**
    * Get the respectively value for the month for a specific group of income forecasts
    *
    * @author: William Prigol Lopes [william@solis.coop.br]
    *
    * @param $data (object): An object containing the necessary parameters to return the value
    *
    * @return (float): balance for the month specified in parameters for income forecasts
    */
    public function getIncomeForecastValueNull($learningPeriodId)
    {
        if ($learningPeriodId == null)
        {
            return false;
        } 
        $sql = '     SELECT A.learningPeriodId,
                            COUNT(enrollSummaryId),
                            E.courseId||\' - \'||E.name||\' (\'||D.courseVersion||\')\',
                            F.unitId||\' - \'||F.description
                       FROM acdEnrollSummary A
                 INNER JOIN acdLearningPeriod B
                      USING (learningPeriodId)
                 INNER JOIN acdPeriod C
                      USING (periodId)
                 INNER JOIN acdCourseOccurrence D
                      USING (courseId, courseVersion, unitId)
                 INNER JOIN acdCourse E
                      USING (courseId)
                 INNER JOIN basUnit F
                      USING (unitId)
                  LEFT JOIN finPrice G
                      USING (learningPeriodId)
                      WHERE A.isProcessed = \''. DB_FALSE . '\' 
                        AND G.value is null 
                        AND learningPeriodId IN ('.$learningPeriodId.')
                   GROUP BY 1, 3, 4 ';
        $res = $this->db->query($sql);
        if(is_array($res))
        {
            return $res;
        }
        return false;
    }

    /**
     * Generate the income forecasts for every nonprocessed entry
     * at acdEnrollSummary table. If something goes wrong, a ROLLBACK
     * is executed. Otherwise, the changes are COMMITed.
     *
     * @return Return true if everything has gone right. Otherwise, return false.
     *
     **/
    public function generateIncomeForecast($learningPeriodIds=null, $contractId=null, $groupId=0, $isAddition=false)
    {
        $MIOLO  = MIOLO::getInstance();
    	$module = 'finance';

        //inclui os defines do academic
        $business = $MIOLO->getBusiness('basic', 'BusConfig');
        $constants = $business->getModuleValues('academic');
        foreach ( $constants as $cnt )
        {
            define($cnt[0],$cnt[1]);
        }

        $busPrice  = $MIOLO->getBusiness('finance', 'BusPrice');

        //verifica se o curso é seriado pelo periodo letivo
        if ( strlen((string)$learningPeriodIds) == 0 )
        {
            $learningPeriodIds = 'NULL';
        }

        // Inicia transação
        $this->db->execute('BEGIN TRANSACTION');

        //seleciona os dados a serem convertidos
        $sql = 'SELECT A.contractId,
                       A.operationId,
                       E.accountSchemeId,
                       E.costCenterId,
                       CASE WHEN isValue = \'' . DB_TRUE . '\'
                            THEN A.multiplier
                            ELSE A.multiplier * C.value
                       END AS value,
                       TO_CHAR(A.recordDate,\'' . MASK_DATE . '\') AS recordDate,
                       TRIM(TO_CHAR(COALESCE(B.maturityDay,10),\'00\')) AS maturityDateDay,';

        //se for uma acréscimo, gera as mensalidades a partir da data atual
        if ( $isAddition == true )
        {
            $sql .= '      TRIM(TO_CHAR(EXTRACT(MONTH FROM date(now()))+1,\'00\')) AS maturityDateMonth, 
                           TRIM(TO_CHAR(EXTRACT(YEAR FROM date(now())),\'0000\')) AS maturityDateYear, ';
        }
        else
        {
            $sql .= '      TRIM(TO_CHAR(EXTRACT(MONTH FROM D.beginDate),\'00\')) AS maturityDateMonth, 
                           TRIM(TO_CHAR(EXTRACT(YEAR FROM D.beginDate),\'0000\')) AS maturityDateYear, ';
        }
        
        $sql .= '      A.parcelsNumber,
                       A.learningPeriodId,
                       A.multiplier,
                       A.enrollSummaryId,
                       A.isValue,
                       D2.courseVersionTypeId as isSerial,
                       A.multiplier,
                       C.value
                  FROM acdEnrollSummary A
            INNER JOIN acdContract B
                    ON (B.contractId = A.contractId)
            INNER JOIN acdLearningPeriod D
                    ON (D.learningPeriodId = A.learningPeriodId)
            INNER JOIN acdCourseVersion D2
                    ON (    D.courseId      = D2.courseId
                        AND D.courseVersion = D2.courseVersion)
            INNER JOIN finPrice C
                    ON (    C.learningPeriodId = D.learningPeriodId
                        AND (C.startDate, C.endDate) OVERLAPS (D.beginDate, D.endDate))
            INNER JOIN accCourseAccount E
                    ON (    E.courseId = B.courseId
                        AND E.courseVersion = B.courseVersion
                        AND E.unitId = B.unitId)
                 WHERE A.isProcessed = \''.DB_FALSE.'\'
                   AND A.learningPeriodId IN (' . $learningPeriodIds . ')';

        if ( strlen((string)$contractId)>0 )
        {
            $sql .= ' AND A.contractId = \'' . $contractId . '\'';
        }

        $sql .= '      ORDER BY 1, 
                                2';

        $res = $this->db->query($sql);

        // For each row, insert a new income forecast
        $keepGoing = true;
       
        // Obtém da BasConfig os descontos curriculares
        $operationIdCurricular = explode(",", CURRICULAR_COMPONENT_DISCOUNT);
        $isDiscountCurricular = false;
        
        // Guarda o total de sumários
        $this->generationData->totalEnrollSummaries = count($res);

        // Processa cada linha retornada da query da enroll summary
        for ( $i=0; (($i<$this->generationData->totalEnrollSummaries) && ($keepGoing)); $i++ )
        {

            //verifica se é serial e se alcançou o mínimo de disciplinas para matrícula cheia
            if ( in_array($res[$i][14], explode(',', str_replace(' ', '', SERIAL_ENROLL_TYPE_IDS) ) ) )
            {
                //se for matricula de mais de um aluno nao vem o numero de disciplinas
                if ( $groupId == 0 )
                {
                    $sql = 'SELECT count(A.*)
                              FROM acdEnroll A
                        INNER JOIN acdGroup B
                                ON ( A.groupId = B.groupId )
                             WHERE A.contractId       = ?
                               AND B.learningPeriodId = ?
                               AND A.statusId         = ?';

                    $args = array ( $res[$i][0],
                                    $res[$i][10],
                                    ENROLL_STATUS_ENROLLED);
                                
                    $countGroups = $this->db->query(SAGU::Prepare($sql, $args));
                    $countGroups = $countGroups[0][0];
                }
                //matriculas individuais trazem o dumero de diciplinas
                else
                {
                    $countGroups = $groupId;
                }

                $sql = 'SELECT value,
                               minimumCurricularComponent,
                               curricularComponentPrice
                          FROM finPrice
                         WHERE learningPeriodId = ?
                           AND date(now()) BETWEEN startDate AND endDate
                      ORDER BY startDate DESC';
                $priceSerial = $this->db->query(SAGU::Prepare($sql, $res[$i][10]));

                //se for menos que o mínimo de disciplinas o valor é por disciplina
                if ( $countGroups < $priceSerial[0][1] )
                {
                    //$res[$i][4] = number_format( ( ($countGroups * $priceSerial[0][2]) / $priceSerial[0][0] * $res[$i][4] ), 8, '.', '');

                //CASO DE INCENTIVOS, se o preco semestral for 5000 e o desconto for de 25% e o preco da disciplina é 1000 e vierem 2 disciplinas selecionadas. O valor que veio calculado pela forma integral, deve ser calculado pelas disciplinas
                //$countGroups       = 2
                //$priceSerial[0][2] = 1000
                //$priceSerial[0][0] = 5000
                //$res[$i][4]        = (2*5000/25%)/5parcelas = 500
                //formula            = (2 * 1000) / (5000 * 500) = 0,0004
                    //var_dump($countGroups,$priceSerial[0][2],$priceSerial[0][0],$res[$i][4]);
                    if ( $isAddition == true )
                    {
                        //$res[$i][4] = number_format( ( ($res[$i][9] * $priceSerial[0][2]) / $priceSerial[0][0] * $res[$i][4] ), 8, '.', '');
                        $res[$i][4] = number_format( $res[$i][4], 8, '.', '');
                    }
                    else
                    {
                        $res[$i][4] = number_format( ( ($res[$i][9] * $priceSerial[0][2]) / $priceSerial[0][0] * $res[$i][4] ), 8, '.', '');
                    }
                }
            }

            //se nao for seriado e se for um valor em percentual(não desconto com valor fixo)
            if ( (in_array($res[$i][14], explode(',', str_replace(' ', '', SERIAL_ENROLL_TYPE_IDS) ) ) == false ) && ($res[$i][13] == DB_FALSE) )
            {
                $res[$i][11] = _M('Referred to @1 credits', $module, SAGU::formatNumber($res[$i][11]));
            }
            else
            {
                $res[$i][11] = _M('Referred by total course price', $module);
            }

            // Verifica se o contrato é diferente ao anterior, se sim, efetua os processamentos para novo contrato
            if ( $contractId != $res[$i][0] )
            {
                $contractId = $res[$i][0];
                if ( $curricularComponentDiscount != null )
                {
                    $data[] = clone($curricularComponentDiscount);
                }
                unset($curricularComponentDiscount);
            }
            
            // Este processo verifica se a operação está dentro da regra de descontos curriculares obtidos no início do processo
            if ((is_array($operationIdCurricular)) & (in_array($res[$i][1], $operationIdCurricular)))
            {
                // Caso esteja, cria um objeto com os valores aglutinados
                if ( $curricularComponentDiscount )
                {
                    if (!in_array($res[$i][1], explode(',', $curricularComponentDiscount->operationId)))
                    {
                        $curricularComponentDiscount->operationIdExtra = $curricularComponentDiscount->operationId.','.$res[$i][1];
                    }
                    $curricularComponentDiscount->value = SAGU::calcNumber($curricularComponentDiscount->value.' + '.$res[$i][4]);
                    
                }
                else
                {
                    list ( $curricularComponentDiscount->contractId,
                           $curricularComponentDiscount->operationId,
                           $curricularComponentDiscount->accountSchemeId,
                           $curricularComponentDiscount->costCenterId,
                           $curricularComponentDiscount->value,
                           $curricularComponentDiscount->recordDate,
                           $curricularComponentDiscount->maturityDateDay,
                           $curricularComponentDiscount->maturityDateMonth,
                           $curricularComponentDiscount->maturityDateYear,
                           $curricularComponentDiscount->parcelsNumber,
                           $curricularComponentDiscount->learningPeriodId,
                           $curricularComponentDiscount->comments) = $res[$i];
                }
            }
            else
            {
                list ( $curricularComponent->contractId,
                       $curricularComponent->operationId,
                       $curricularComponent->accountSchemeId,
                       $curricularComponent->costCenterId,
                       $curricularComponent->value,
                       $curricularComponent->recordDate,
                       $curricularComponent->maturityDateDay,
                       $curricularComponent->maturityDateMonth,
                       $curricularComponent->maturityDateYear,
                       $curricularComponent->parcelsNumber,
                       $curricularComponent->learningPeriodId,
                       $curricularComponent->comments,
                       $curricularComponent->enrollSummaryId) = $res[$i];
                       
                $data[] = clone($curricularComponent);
                unset($curricularComponent);
            }
        }

        // O último componente de desconto tem que ser inserido após percorrer todo o array.
        if ( $curricularComponentDiscount != null )
        {
            $data[] = clone($curricularComponentDiscount);
            unset($curricularComponentDiscount);
        }

        //gera as previsoes
        if ( is_array($data) )
        {
            $businessOperation         = $MIOLO->getBusiness($module, 'BusOperation');
            $businessReceivableInvoice = $MIOLO->getBusiness($module, 'BusReceivableInvoice');
            $businessContract          = $MIOLO->getBusiness('academic', 'BusContract');
            $businessLearningPeriod    = $MIOLO->getBusiness('academic', 'BusLearningPeriod');

            // Process data (percorre todos os alunos)
            foreach ( $data as $key => $dt )
            {

                //pega as informações da data de vencimento
                $learningPeriod = $businessLearningPeriod->getLearningPeriod($dt->learningPeriodId);
                $contract       = $businessContract->getContract($dt->contractId);
                $haveEnrollFee  = $businessReceivableInvoice->haveEnrollFee($contract->personId, $learningPeriod->beginDate, $learningPeriod->endDate, $contract->courseId, $contract->courseVersion, $contract->unitId);

                //se nao tiver taxa de matricula e nao for acréscimo
                if ( $haveEnrollFee != false && $isAddition != true )
                {
                    if ( (int)$dt->maturityDateMonth == 12 )
                    {
                        $dt->maturityDateMonth = 1;
                        (int)$dt->maturityDateYear++;
                    }
                    elseif ( $isAddition != true )
                    {
                        (int)$dt->maturityDateMonth++;
                    }
                }

                // Get needed information to generate the income forecasts
                $parcelsValues      = $this->getParcelsValues($dt->value, $dt->parcelsNumber);

                $defaultOperationId = $this->getDefaultOperationIdForEnroll($dt->learningPeriodId);
                $operationInfo      = $dt->operationId.' - '.$businessOperation->getOperationDescription($dt->operationId);

                // Get information to show process data on browser
                $this->generationData->contracts[$key]->contractId    = $dt->contractId;
                $this->generationData->contracts[$key]->operationId   = $operationInfo;
                $this->generationData->contracts[$key]->parcelsNumber = $dt->parcelsNumber;
                $this->generationData->contracts[$key]->value         = $dt->value;

                //pega o número de previsões já geradas
                $sql = 'SELECT count(months)
                         FROM (SELECT DISTINCT EXTRACT(MONTH FROM maturitydate) as months 
                                 FROM finincomeforecast 
                                WHERE contractid  = ? 
                                  AND isprocessed = \'' . DB_TRUE . '\'
                                  AND maturityDate BETWEEN TO_DATE(?,\'' . MASK_DATE . '\') AND
                                                           TO_DATE(?,\'' . MASK_DATE . '\')) AS sel';
            
                $args = array($dt->contractId,
                              $learningPeriod->beginDate,
                              $learningPeriod->endDate);

                $genParcels = $this->db->query(SAGU::prepare($sql, $args));
                $genParcels = strlen((string)$genParcels[0][0])>0 ? $genParcels[0][0] : 0;

                // For each parel number, insert the relative income forecast
                for ($parcelNumber = 0; ($parcelNumber < $dt->parcelsNumber) && $keepGoing; $parcelNumber++)
                {

                    $year_  = $dt->maturityDateYear;
                    $month_ = $dt->maturityDateMonth;
                    $day_   = $dt->maturityDateDay;

                    //calculo das datas para matriculas normais, sem acrescimos
                    if ( $isAddition != true )
                    {
                        //incrementa a data para nao cair num mês já gerado
                        for ( $t=0; $t<$genParcels; $t++ )
                        {
                           $month_++;
                            if ( $month_ > 12 )
                            {
                                $month_ = 1;
                                $year_++;
                            }
                        }
                    }

                    // Se ja tiver previsao gerada naquele mês, joga pro próximo
                    $matDate = $this->addMonths($year_,
                                                $month_,
                                                $day_, 
                                                $parcelNumber);

                    $dt->maturityDate = SAGU::toDefaultDate($matDate->day.'-'.$matDate->month.'-'.$matDate->year, 'dd-mm-yyyy');
                    // Mark as true to indicate that these income forecasts will be created by sagu automatic process.
                    $dt->isGenerated = DB_TRUE; 
                    // Obtain the array of parcels values
                    $dt->value = $parcelsValues[$parcelNumber];

                    // Insert the specific income forecast
                    $keepGoing = (! is_null($this->insertIncomeForecast($dt)));
                    
                    if ( $keepGoing )
                    {
                        // Mark this enroll summary entry as processed
                        $sql = 'UPDATE acdEnrollSummary
                                   SET isProcessed      = \''.DB_TRUE.'\'
                                 WHERE contractId       = ?
                                   AND learningPeriodId = ?
                                   AND recordDate       = TO_DATE(?,\'' . MASK_DATE . '\')
                                   AND operationId      IN ('.(strlen((string)$dt->operationIdExtra)>0 ? $dt->operationIdExtra : $dt->operationId).') ';

                        $args = array ( $dt->contractId,
                                        $dt->learningPeriodId,
                                        $dt->recordDate );

                        $sqls = SAGU::prepare($sql,$args);
                        for ( $upd = 0; ($upd < count($sqls)) && $keepGoing; $upd++ )
                        {
                            $keepGoing = $this->db->execute($sqls[$upd]);
                        }
                    }
                }
            }
        }
        $this->db->execute(($keepGoing ? 'COMMIT' : 'ROLLBACK'));
        return $keepGoing;
    }
    
    /**
     * Filter the learningPeriods for generationIncomeForecast
     *
     **/
    public function getLearningPeriods($filters)
    {
        $sql = '     SELECT A.learningPeriodId,
                            COUNT(A.learningPeriodId),
                            C.courseId||\' - \'||getCourseName(C.courseId)||\' (\'||B.courseVersion||\')\',
                            B.unitId||\' - \'||getUnitDescription(B.unitId),
                            B.turnId||\' - \'||getTurnDescription(B.turnId),
                            B.courseId,
                            B.courseVersion,
                            B.unitId,
                            B.turnId,
                            F.costCenterId
                       FROM acdEnrollSummary A
                 INNER JOIN acdLearningPeriod B
                      USING (learningPeriodId)
                 INNER JOIN acdCourseOccurrence C
                      USING (courseId, courseVersion, unitId)
                  LEFT JOIN finPrice E
                         ON ( E.learningPeriodId = B.learningPeriodId
                          AND (E.startDate, E.endDate) OVERLAPS (B.beginDate, B.endDate))
                  LEFT JOIN accCourseAccount F
                         ON (B.courseId = F.courseId 
                         AND B.courseVersion = F.courseVersion
                         AND B.unitId = F.unitId ) ';
        if ( strlen((string)$filters->formationLevelId) > 0 )
        {
            $where .= ' AND B.formationLevelId = ? ';
            $args[] = $filters->formationLevelId;
        }

        if ( strlen((string)$filters->periodId) > 0 )
        {
            $where .= ' AND B.periodId = ? ';
            $args[] = $filters->periodId;
        }

        if ( strlen((string)$filters->courseId) > 0 )
        {
            $where .= ' AND B.courseId = ? ';
            $args[] = $filters->courseId;
        }

        if ( strlen((string)$filters->courseVersion) > 0 )
        {
            $where .= ' AND B.courseVersion = ? ';
            $args[] = $filters->courseVersion;
        }

        unset($result);
        if ( strlen((string)$where) > 0 )
        {
            $sql .= ' WHERE A.isProcessed = \''. DB_FALSE . '\' ' . $where . ' GROUP BY 1, 3, 4, 5, 6, 7 ,8, 9, 10 ';
            $db = $this->getDatabase();
            $result = $db->query(SAGU::prepare($sql, $args));
        }
        return $result;
    }
     
   /**
    * get income forecast person in current month
    *
    * @param  contractId, learningPeriodId, maturitydate, A.maturityDate BETWEEN D.beginDate AND D.endDate
    *
    * @return All Income forecast in this period
    *
   **/
    public function getIncomeForecastPerson($data, $month)
    {
        $MIOLO  = MIOLO::getInstance();
        $module = 'finance';

        $sql ='    SELECT A.incomeForecastId,
                          B.courseId||\' - \'||B.courseVersion||\'(\'||getCourseName(B.courseId),
                          A.comments,
                          C.operationId||\' - \'||C.description,
                          C.operationTypeId,
                          B.unitId,
                         ( SELECT description 
                             FROM basUnit
                            WHERE basUnit.unitId = B.unitId) as unitDescription,
                          TO_CHAR(A.recorddate, \'' . MASK_DATE . '\'),
                          TO_CHAR(A.maturityDate, \'' . MASK_DATE . '\'),                       
                          ROUND(A.value, 2),
                          A.isProcessed,
                          A.isGenerated,
                          A.isSupressed
                     FROM finIncomeForecast A
               INNER JOIN acdContract B
                    USING (contractId)                
               INNER JOIN finOperation C
                    USING (operationId)
               INNER JOIN acdLearningPeriod D
                       ON ( B.courseId = D.courseId
                        AND B.courseVersion = D.courseVersion
                        AND B.unitId = D.unitId
                        AND B.turnId = D.turnId )
                    WHERE B.contractId = ?
                      AND D.learningPeriodId = ?
                      AND extract(MONTH FROM A.maturitydate) = ?
                      AND A.maturityDate BETWEEN D.beginDate AND D.endDate
                 ORDER BY A.recorddate ';
          

        $sql ='    SELECT A.incomeForecastId,
                          B.courseId||\' - \'||B.courseVersion||\'(\'||getCourseName(B.courseId),
                          A.comments,
                          C.operationId||\' - \'||C.description,
                          C.operationTypeId,
                          B.unitId,
                         ( SELECT description 
                             FROM basUnit
                            WHERE basUnit.unitId = B.unitId) as unitDescription,
                          TO_CHAR(A.recorddate, \'' . MASK_DATE . '\'),
                          TO_CHAR(A.maturityDate, \'' . MASK_DATE . '\'),                       
                          ROUND(A.value, 2),
                          A.isProcessed,
                          A.isGenerated,
                          A.isSupressed
                     FROM acdLearningPeriod D,
                          finIncomeForecast A
               INNER JOIN acdContract B
                    USING (contractId)                
               INNER JOIN finOperation C
                    USING (operationId)
                    WHERE B.contractId = ?
                      AND D.learningPeriodId = ?
                      AND extract(MONTH FROM A.maturitydate) = ?
                      AND A.maturityDate BETWEEN D.beginDate AND D.endDate
                 ORDER BY A.recorddate ';

        $res = $this->db->query(SAGU::prepare($sql, array($data->contractId, $data->learningPeriodId, $month) ) );
        
    	if (is_array($res[0]))
        {
            for ($x = 0; $x<count($res); $x++)
            {
                $res[$x][13] = $res[$x][12];
                // curso
                $str        = $res[$x][1];
                $path       = $MIOLO->getActionURL($module, 'html:images:info.png');
                $string     = new MImage('imgCourse'.$x, $str, $path);
                $res[$x][1] = $string->generate(); 
            
                // Comentários com imagem e hint
                $str        = strlen((string)$res[$x][2])>0 ? $res[$x][2] : _M('No comments', $module);
                $path       = $MIOLO->getActionURL($module, 'html:images:obs.png');
                $string     = new MImage('imgComments'.$x, $str, $path);
                $res[$x][2] = $string->generate(); 
                
                // Verifica qual unidade em que ele está (Padrão ou não).
                $str        = ($res[$x][5] == DEFAULT_UNIT_ID) ? _M('In the default unit - @1', $module, $res[$x][6]) : _M('Out of default unit - @1', $module, $res[$x][6]);
                $path       = $MIOLO->getActionURL($module, ($res[$x][5] == DEFAULT_UNIT_ID) ? 'html:images:checkOn.png' : 'html:images:checkOff.png');
                $string     = new MImage('imgUnit'.$x, $str, $path);
                $res[$x][5] = $string->generate();

                // Tipo - Se foi gerado pelo sistema ou pelo usuário
                //      Vermelho = Sistema
                //      Amarelo  = Usuário
                if ($res[$x][11] == DB_TRUE) 
                {
                    $imgType = 'red';
                    $res[$x][12] = DB_TRUE;
                }
                else
                {
                    $imgType = 'green';
                    $res[$x][12] = DB_FALSE;
                }
                
                // Tipo - Se foi processado
                //      Quadrado = Processado 
                //      Bola     = Não processado
                if ($res[$x][10] == DB_TRUE)
                {
                    $imgType.= 'Square';
                    $str     = _M('Can\'t modify value', $module);
                    $res[$x][11] = DB_TRUE;
                }
                else
                {
                    $imgType.= 'Ball';
                    $str     = _M('Modify value', $module);
                    $res[$x][11] = DB_FALSE;
                }
                $path     = $MIOLO->getActionURL($module, 'html:images:'.$imgType.'.png');
                $string   = new MImage('imgStatus'.$x, $str, $path);
                $res[$x][10] = $string->generate();


	        }
        }
        return $res;
    }    

     /**
     * get income forecast person where incomeForecastId for edit.
     *
     * @param  contractId, learningPeriodId, incomeForecastId
     *
     * @return One IncomeForecast data
     *
     **/
    public function getIncomeForecastEditPerson($incomeForecastId, $contractId, $learningPeriodId)
    {
      $sql ='SELECT A.contractId,
                    A.incomeForecastId,
                    C.operationId,
                    C.description,
                    C.operationTypeId,
                    to_char(A.recorddate, \'' . MASK_DATE . '\'),
                    A.value,
                    A.isAccounted,
                    D.learningPeriodId,
                    to_char(A.maturityDate, \'' . MASK_DATE . '\'),
                    A.accountSchemeid,
                    A.costCenterId,
                    A.comments,
                    A.isGenerated,
                    A.isProcessed,
                    A.userName,
                    TO_CHAR(A.dateTime,\'' . MASK_TIMESTAMP . '\')
               FROM finIncomeForecast A,
                    acdContract B,
                    finOperation C,
                    acdLearningPeriod D
              WHERE A.contractId = B.contractId
                AND B.courseId = D.courseId
                AND B.courseVersion = D.courseVersion
                AND C.operationId = A.operationId
                AND B.unitId = D.unitId
                AND B.turnId = D.turnId
                AND B.contractId = ?
                AND D.learningPeriodId = ?
                AND A.incomeForecastId = ?
                AND A.maturityDate BETWEEN D.beginDate AND D.endDate
           ORDER BY A.recorddate ';

         $res = $this->db->query(SAGU::prepare($sql, array($contractId, $learningPeriodId, $incomeForecastId) ) );

         list ( $income->contractId,
                $income->incomeForecastId,
                $income->operationId,
                $income->description,
                $income->operationTypeId,
                $income->recordDate,
                $income->value,
                $income->isAccounted,
                $income->learningPeriodId,
                $income->maturityDate,
                $income->accountSchemeId,
                $income->costCenterId,
                $income->comments,
                $income->isGenerated,
                $income->isProcessed,
                $income->userName,
                $income->dateTime
                ) = $res[0];
        return $income;
    }

     /**
     * get mount and total off learningPeriodId on incomeforecast period
     *
     * @param  contractId, learningPeriodId, A.maturityDate BETWEEN D.beginDate AND D.endDate
     *
     * @return mount and total off month
     *
     **/
    public function getMonthValue($data=null)
    {
          $sql = ' SELECT month, 
                          sum( round(sumValue, 2) ) 
                    FROM ( SELECT extract(MONTH FROM A.maturitydate) as month,
                                  A.value * (CASE WHEN C.operationTypeId = \'D\' THEN 1 WHEN
                                  C.operationTypeId = \'C\' THEN -1 END)  as sumValue
                             FROM finIncomeForecast A,
                                  acdContract B,
                                  finOperation C,
                                  acdLearningPeriod D
                            WHERE A.contractId = B.contractId
                              AND B.courseId = D.courseId
                              AND B.courseVersion = D.courseVersion
                              AND C.operationId = A.operationId
                              AND B.unitId = D.unitId
                              AND B.turnId = D.turnId
                              AND B.contractId = ?
                              AND D.learningPeriodId = ?
                              AND A.maturityDate BETWEEN D.beginDate AND D.endDate
                        ORDER BY 1 )
                                    AS A 
                    GROUP BY 1 ' ;

          $sql = ' SELECT month, 
                          sum( round(sumValue, 2) ) 
                    FROM ( SELECT extract(MONTH FROM A.maturitydate) as month,
                                  A.value * (CASE WHEN C.operationTypeId = \'D\' THEN 1 WHEN
                                  C.operationTypeId = \'C\' THEN -1 END)  as sumValue
                             FROM finIncomeForecast A,
                                  acdContract B,
                                  finOperation C,
                                  acdLearningPeriod D
                            WHERE A.contractId = B.contractId
                              --AND B.courseId = D.courseId
                              --AND B.courseVersion = D.courseVersion
                              AND C.operationId = A.operationId
                              --AND B.unitId = D.unitId
                              --AND B.turnId = D.turnId
                              AND B.contractId = ?
                              AND D.learningPeriodId = ?
                              AND A.maturityDate BETWEEN D.beginDate AND D.endDate
                        ORDER BY 1 )
                                    AS A 
                    GROUP BY 1 ' ;

         $res = $this->db->query(SAGU::prepare($sql, array($data->contractId, $data->learningPeriodId) ) );
         return $res;
    
     } 

     /**
     * get mount and total off month and learningPeriodId on incomeforecast period 
     *
     * @param  contractId, learningPeriodId, A.maturityDate BETWEEN D.beginDate AND D.endDate
     *
     * @return mount and total off month for a current month
     *
     **/
    public function getCurrentMonthValue($data=null)
    {
          $sql = ' SELECT month,
                          sum( round(sumValue, 2) )
                    FROM ( SELECT extract(MONTH FROM A.maturitydate) as month,
                                  A.value * (CASE WHEN C.operationTypeId = \'D\' THEN 1 WHEN
                                  C.operationTypeId = \'C\' THEN -1 END)  as sumValue
                             FROM finIncomeForecast A,
                                  acdContract B,
                                  finOperation C,
                                  acdLearningPeriod D
                            WHERE A.contractId = B.contractId
                              AND B.courseId = D.courseId
                              AND B.courseVersion = D.courseVersion
                              AND C.operationId = A.operationId
                              AND B.unitId = D.unitId
                              AND B.turnId = D.turnId
                              AND B.contractId = ?
                              AND D.learningPeriodId = ?
                              AND extract(MONTH FROM A.maturitydate) = extract(MONTH FROM TO_DATE(?, \'' . MASK_DATE . '\'))
                              AND A.maturityDate BETWEEN D.beginDate AND D.endDate
                              ORDER BY 1 )
                                    AS A
                    GROUP BY 1 ' ;

         $res = $this->db->query(SAGU::prepare($sql, array($data->contractId, $data->learningPeriodId, $data->maturityDate) ) );
         return $res;

     }

     /**
     * get mount of income forecast period
     *
     * @param  contractId, learningPeriodId,  BETWEEN D.beginDate AND D.endDate
     *
     * @return mount 
     *
     **/
    public function getMonth($data=null)
    {
        $sql= '  SELECT DISTINCT extract(MONTH FROM A.maturityDate )
                   FROM finIncomeForecast A,
                        acdContract B,
                        finOperation C,
                        acdLearningPeriod D
                  WHERE A.contractId = B.contractId
                    AND B.courseId = D.courseId
                    AND B.courseVersion = D.courseVersion
                    AND C.operationId = A.operationId
                    AND B.unitId = D.unitId
                    AND B.turnId = D.turnId
                    AND B.contractId = ?
                    AND D.learningPeriodId = ?
                    AND A.maturityDate BETWEEN D.beginDate AND D.endDate
               ORDER BY 1 ';
               
        $sql= '  SELECT DISTINCT extract(MONTH FROM A.maturityDate )
                   FROM finIncomeForecast A,
                        acdLearningPeriod D
                  WHERE A.contractId       = ?
                    AND D.learningPeriodId = ?
                    AND A.maturityDate BETWEEN D.beginDate AND D.endDate
               ORDER BY 1 ';
               
         $res = $this->db->query(SAGU::prepare($sql, array($data->contractId, $data->learningPeriodId) ) );

         return $res;
    } 
    
     /**
     * get mount of income forecast period
     *
     * @param  contractId, learningPeriodId,  BETWEEN D.beginDate AND D.endDate
     *
     * @return mount 
     *
     **/
    public function getMonthAndYear($data=null)
    {
        $sql= '  SELECT DISTINCT extract(MONTH FROM A.maturityDate ),
                                 extract(YEAR FROM A.maturityDate )
                   FROM finIncomeForecast A,
                        acdContract B,
                        finOperation C,
                        acdLearningPeriod D
                  WHERE A.contractId = B.contractId
                    AND B.courseId = D.courseId
                    AND B.courseVersion = D.courseVersion
                    AND C.operationId = A.operationId
                    AND B.unitId = D.unitId
                    AND B.turnId = D.turnId
                    AND B.contractId = ?
                    AND D.learningPeriodId = ?
                    AND A.maturityDate BETWEEN D.beginDate AND D.endDate
               ORDER BY 1 ';
               
        $sql= '  SELECT DISTINCT extract(MONTH FROM A.maturityDate ),
                                 extract(YEAR FROM A.maturityDate )
                   FROM finIncomeForecast A,
                        acdLearningPeriod D
                  WHERE A.contractId       = ?
                    AND D.learningPeriodId = ?
                    AND A.maturityDate BETWEEN D.beginDate AND D.endDate
               ORDER BY 1 ';

         $res = $this->db->query(SAGU::prepare($sql, array($data->contractId, $data->learningPeriodId) ) );

         return $res;
    } 
    
     /**
     * get income forecast id from a period
     *
     * @param  contractId, learningPeriodId, A.maturityDate BETWEEN D.beginDate AND D.endDate
     *
     * @return any incomeForecastIds
     *
     **/
    public function getIncomeForecastIds($data=null)
    {
            $sql =  ' SELECT A.incomeForecastId     
                        FROM finIncomeForecast A,   
                             acdContract B,
                             finOperation C,
                             acdLearningPeriod D
                       WHERE A.contractId = B.contractId
                         AND B.courseId = D.courseId
                         AND B.courseVersion = D.courseVersion
                         AND C.operationId = A.operationId
                         AND B.unitId = D.unitId
                         AND B.turnId = D.turnId
                         AND B.contractId = ?
                         AND D.learningPeriodId = ?
                         AND extract(MONTH FROM A.maturitydate) = 
                                        extract(MONTH FROM TO_DATE( ? , \'' . MASK_DATE . '\'))
                         AND A.maturityDate BETWEEN D.beginDate AND D.endDate
                         ORDER BY 1 ';

           $res = $this->db->query(SAGU::prepare($sql, array($data->contractId, $data->learningPeriodId, $data->maturityDate) ) );

           return $res; 

    } 


    public function getMonthlyFeeForPeriod($data=null)
    {
            $MIOLO = MIOLO::getInstance();

            $sql = ' SELECT DISTINCT extract(MONTH FROM A.maturityDate)
                             FROM finIncomeForecast A,
                                  acdContract B,
                                  finOperation C,
                                  acdLearningPeriod D
                            WHERE A.contractId = B.contractId
                              AND B.courseId = D.courseId
                              AND B.courseVersion = D.courseVersion
                              AND C.operationId = A.operationId
                              AND B.unitId = D.unitId
                              AND B.turnId = D.turnId
                              AND B.contractId = ?
                              AND D.learningPeriodId = ?
                              AND C.operationId = ?
                              AND A.maturityDate BETWEEN D.beginDate AND D.endDate
                              ORDER BY 1 ';

            if ( strlen((string) DEFAULT_OPERATIONID_MONTHLY_FEE ) == 0 )
            {
                    $url = $MIOLO->getActionURL($module, 'main:config:parametersTable');
                    $MIOLO->error(_M('Couldn\'t set DEFAULT_OPERATIONID_MONTHLY_FEE in table of parameters.', $module), $url);

            }

            $res = $this->db->query(SAGU::prepare($sql, array($data->contractId, $data->learningPeriodId, DEFAULT_OPERATIONID_MONTHLY_FEE) ) );

           return $res;
       
    }


     /**
     * Generate update finincomeforecast  SET isprocessed = true
     *
     * @param  incomeforecastid
     *
     * @return true or false
     *
     **/
    public function generateUpdateIncomeForecast($data=null)
    {
            $return = true;
            for ( $i=0; $i<count($data); $i++ )
            {   
                $sql = 'UPDATE finincomeforecast 
                           SET isprocessed = true
                         WHERE incomeforecastid = ? ';
                $res = $this->db->execute(SAGU::prepare($sql, $data[$i][0] ) );
                if ($this->db->getErrors())
                {
                    $return = false;
                } 
            }
            return $return;

    }    

    /**
     * Verify if is processed
     *
     * @param $incomeForecastId (int): Primary key for income forecast
     *
     * @return True if runs otherwise is false
     *
     */
     public function isProcessed($incomeForecastId)
     {
        $sql = ' SELECT isProcessed
                   FROM finIncomeForecast 
                  WHERE incomeForecastId = ? ';
                  
        $res = $this->db->query(SAGU::prepare($sql, $incomeForecastId));
        return $res[0][0];
     }

    /**
     * Insert a new record
     *
     * @param $data (object): An object of the type handled by the class
     *
     * @return If succed, return the invoice id. Otherwise return FALSE.
     *
     **/
     public function insertInvoice($data)
     {
        $sql = 'SELECT NEXTVAL(\'seq_invoiceId\')';
        $retVal = $this->db->query($sql);
        $invoiceId = false;
        if ( isset($retVal[0][0]) )
        {
            $invoiceId = $retVal[0][0];

            $field[] = 'invoiceId';
            $prepareValue[] = '?';
            $dataValue[] = $invoiceId;
            $field[] = 'personId';
            $prepareValue[] = '?';
            $dataValue[] = $data->personId;
            $field[] = 'accountSchemeId';
            $prepareValue[] = '?';
            $dataValue[] = $data->accountSchemeId;
            $field[] = 'costCenterId';
            $prepareValue[] = '?';
            $dataValue[] = $data->costCenterId;
            $field[] = 'courseId';
            $prepareValue[] = '?';
            $dataValue[] = $data->courseId;
            $field[] = 'courseVersion';
            $prepareValue[] = '?';
            $dataValue[] = $data->courseVersion;
            $field[] = 'unitId';
            $prepareValue[] = '?';
            $dataValue[] = $data->unitId;
            $field[] = 'parcelNumber';
            $prepareValue[] = '?';
            $dataValue[] = $data->parcelNumber;
            $field[] = 'emissionDate';
            if ( is_null($data->emissionDate) )
            {
                $prepareValue[] = 'now()';
            }
            else
            {
                $prepareValue[] = 'TO_DATE(?,\'' . MASK_DATE . '\')';
                $dataValue[] = $data->emissionDate;
            }
            $field[] = 'maturityDate';
            $prepareValue[] = 'TO_DATE(?,\'' . MASK_DATE . '\')';
            $dataValue[] = $data->maturityDate;
            $field[] = 'value';
            $prepareValue[] = '?';
            $dataValue[] = $data->value;
            $field[] = 'policyId';
            $prepareValue[] = '?';
            $dataValue[] = $data->policyId;
            $field[] = 'bankInvoiceId';
            $prepareValue[] = '?';
            $dataValue[] = $data->bankInvoiceId;
            $field[] = 'automaticDebit';
            $prepareValue[] = '?';
            $dataValue[] = $data->automaticDebit;
            $field[] = 'comments';
            $prepareValue[] = '?';
            $dataValue[] = $data->comments;
            $field[] = 'incomeSourceId';
            $prepareValue[] = '?';
            $dataValue[] = $data->incomeSourceId;
            $field[] = 'bankAccountId';
            $prepareValue[] = '?';
            $dataValue[] = $data->bankAccountId;
            $field[] = 'bankContractId';
            $prepareValue[] = '?';
            $dataValue[] = $data->bankContractId;
            $field[] = 'messageInvoice';
            $prepareValue[] = '?';
            $dataValue[] = $data->messageInvoice;
            $field[] = 'sagu1InvoiceId';
            $prepareValue[] = '?';
            $dataValue[] = $data->sagu1InvoiceId;

            $sql = 'INSERT INTO finInvoice
                                (';
            for ( $i=0; $i<count($field); $i++ )
            {
                $sql .= $field[$i] . ',';
            }
            $sql = substr($sql, 0, strlen((string)$sql)-1) . ')
                         VALUES (';
            for ( $i=0; $i<count($prepareValue); $i++ )
            {
                $sql .= $prepareValue[$i] . ',';
            }
            $sql = substr($sql, 0, strlen((string)$sql)-1) . ')';

            if ( ! $this->db->execute(SAGU::prepare($sql, $dataValue)) )
            {
                $invoiceId = false;
            }
        }

        return $invoiceId;
     }

   /**
     * Insert a new record
     *
     * @param $data (object): An object of the type handled by the class
     *
     * @return The new generated invoice id if succed, otherwise FALSE
     *
     **/
     public function insertReceivableInvoice($data)
     {
        $invoiceId = $this->insertInvoice($data);

        if ( $invoiceId !== false )
        {
            unset($field, $prepareValue, $dataValue);

            $field[] = 'invoiceId';
            $prepareValue[] = '?';
            $dataValue[] = $invoiceId;
            $field[] = 'personId';
            $prepareValue[] = '?';
            $dataValue[] = $data->personId;
            $field[] = 'accountSchemeId';
            $prepareValue[] = '?';
            $dataValue[] = $data->accountSchemeId;
            $field[] = 'costCenterId';
            $prepareValue[] = '?';
            $dataValue[] = $data->costCenterId;
            $field[] = 'courseId';
            $prepareValue[] = '?';
            $dataValue[] = $data->courseId;
            $field[] = 'courseVersion';
            $prepareValue[] = '?';
            $dataValue[] = $data->courseVersion;
            $field[] = 'unitId';
            $prepareValue[] = '?';
            $dataValue[] = $data->unitId;
            $field[] = 'parcelNumber';
            $prepareValue[] = '?';
            $dataValue[] = $data->parcelNumber;
            $field[] = 'emissionDate';
            if ( is_null($data->emissionDate) )
            {
                $prepareValue[] = 'now()';
            }
            else
            {
                $prepareValue[] = 'TO_DATE(?,\'' . MASK_DATE . '\')';
                $dataValue[] = $data->emissionDate;
            }
            $field[] = 'maturityDate';
            $prepareValue[] = 'TO_DATE(?,\'' . MASK_DATE . '\')';
            $dataValue[] = $data->maturityDate;
            $field[] = 'value';
            $prepareValue[] = '?';
            $dataValue[] = $data->value;
            $field[] = 'policyId';
            $prepareValue[] = '?';
            $dataValue[] = $data->policyId;
            $field[] = 'bankInvoiceId';
            $prepareValue[] = '?';
            $dataValue[] = $data->bankInvoiceId;
            $field[] = 'automaticDebit';
            $prepareValue[] = '?';
            $dataValue[] = $data->automaticDebit;
            $field[] = 'comments';
            $prepareValue[] = '?';
            $dataValue[] = $data->comments;
            $field[] = 'incomeSourceId';
            $prepareValue[] = '?';
            $dataValue[] = $data->incomeSourceId;
            $field[] = 'bankAccountId';
            $prepareValue[] = '?';
            $dataValue[] = $data->bankAccountId;
            $field[] = 'bankContractId';
            $prepareValue[] = '?';
            $dataValue[] = $data->bankContractId;
            $field[] = 'sagu1InvoiceId';
            $prepareValue[] = '?';
            $dataValue[] = $data->sagu1InvoiceId;
            $field[] = 'messageInvoice';
            $prepareValue[] = '?';
            $dataValue[] = $data->messageInvoice;
            $field[] = 'sendDate';
            $prepareValue[] = 'TO_DATE(?,\'' . MASK_DATE . '\')';
            $dataValue[] = $data->sendDate;
            $field[] = 'returnDate';
            $prepareValue[] = 'TO_DATE(?,\'' . MASK_DATE . '\')';
            $dataValue[] = $data->returnDate;
            $field[] = 'returnFileId';
            $prepareValue[] = '?';
            $dataValue[] = $data->returnFileId;

            $sql = 'INSERT INTO finReceivableInvoice
                                (';
            for ( $i=0; $i<count($field); $i++ )
            {
                $sql .= $field[$i] . ',';
            }
            $sql = substr($sql, 0, strlen((string)$sql)-1) . ')
                         VALUES (';
            for ( $i=0; $i<count($prepareValue); $i++ )
            {
                $sql .= $prepareValue[$i] . ',';
            }
            $sql = substr($sql, 0, strlen((string)$sql)-1) . ')';

            if ( ! $this->db->execute(SAGU::prepare($sql, $dataValue)) )
            {
                $invoiceId = false;
            }
        }

        return $invoiceId;
 
     }

    /**
     * Generate update finInvoice  SET value = balance
     *
     * @param  value ( balance ())
     *
     * @return true or false
     *
     **/
     public function updateInvoiceValue($value, $invoiceId)
     {
             $sql = 'UPDATE finInvoice SET value = ? WHERE invoiceId = ? ';
             $res = $this->db->execute(SAGU::prepare($sql, array ($value, $invoiceId ) ) );

             if ($this->db->getErrors())
             {
                 $return = false;
             }

            return $return;

     }
 
     /**
     * Insert a new record
     *
     * @param $data (object): An object of the type handled by the class
     *
     * @return If succed, return the invoice id. Otherwise return FALSE.
     *
     **/
     public function insertEntry($data)
     {
        $sql = ' INSERT INTO finEntry
                            ( invoiceId,
                              operationId,
                              entryDate,
                              value,
                              costCenterId,
                              comments,
                              bankReturnCode,
                              isAccounted,
                              creationType
                            )
                      VALUES (?, ?, to_date(date(now()), \''.MASK_DATE.'\'), ?, ?, ?, ?, ?, ?) ';
                      
        $db = $this->getDatabase();

        $args = array( $data->invoiceId,
                       $data->operationId,
                       $data->value,
                       $data->costCenterId,
                       $data->comments, 
                       $data->bankReturnCode,
                       $data->isAccounted,
                       $data->creationType 
                     );

         $return = $db->execute(SAGU::prepare($sql, $args));
     
         if ($this->db->getErrors())
         {
            $return = false;
         }
         return $return;
           
     }

     /**
     * Generate close Income forecast from a period
     *
     * @param  $data
     *
     * @return true or false
     *
     **/
    public function generateCloseIncomeForecast($data=null)
    {
            $MIOLO = MIOLO::getInstance();

            $this->db->execute('BEGIN TRANSACTION');
            $keepGoing = true;

            $businessDefaultOperations = $MIOLO->getBusiness($module, 'BusDefaultOperations');
            $dataDefaultOperations = $businessDefaultOperations->getDefaultOperations();

            // Default operation Id for Close Income Forecast
            $data->operationId =  $dataDefaultOperations->closeIncomeForecastOperation;
            $data->comments    =  '-';
            // set manual generation
            $data->isGenerated = DB_FALSE;
        
            $data->value       =  $data->monthValue;
            // Insert Close income forecast
            $incomeForecastIdInsert = $this->insertIncomeForecast($data);
            if ( strlen((string)$incomeForecastIdInsert) == 0 || $incomeForecastIdInsert == null )
            {
                $keepGoing = false;
            }

            // get all incomeForecastIds on period
            if ( $keepGoing )
            {            
                $incomeForecastIds = $this->getIncomeForecastIds($data);
                if(count($incomeForecastIds) == 0 || $incomeForecastIds == null)
                {
                    $keepGoing = false;
                }
            }
            
            // set update finincomeforecast  SET isprocessed = true
            if ( $keepGoing )
            {
                $result = $this->generateUpdateIncomeForecast($incomeForecastIds);
                if ($result == false)
                {
                    $keepGoing = false;          
                }
            }

            // get data contract for Invoice            
            if ( $keepGoing )
            {
                $business      = $MIOLO->getBusiness('academic', 'BusContract');
                $contractData  = $business->getContract($data->contractId);
          
                if(count($contractData) == 0 || $contractData == null)
                {
                    $keepGoing = false;
                }

                
            }
            
            // get data Leaning Period (policy) for Invoice
            if ( $keepGoing )
            {
                $business      = $MIOLO->getBusiness('academic', 'BusLearningPeriod');
                $learningData  = $business->getLearningPeriod($data->learningPeriodId);

                
                if( count($learningData) == 0 || $learningData == null )
                {
                    $keepGoing = false;
                }

               
            }

            $actualDate_    =  getDate();
            $actualDate     = $actualDate_[mday] . '/'. $actualDate_[mon] . '/' . $actualDate_[year];
                        
            // get is automaticDebit
            if($keepGoing)
            {
                $sql =  ' SELECT bankId, 
                                 branchNumber,
                                 branchNumberDigit,
                                 accountNumber,
                                 accountNumberDigit
                            FROM finBankTarget 
                           WHERE contractId = ? ';

                $isAutomaticDebit = $this->db->query(SAGU::prepare($sql, $data->contractId) );
                if ( count ( $isAutomaticDebit ) == 0 )
                {
                    $automaticDebit = DB_FALSE;
                }
                else
                {
                    $automaticDebit = DB_TRUE;
                }
                   
            }
            
            $monthlyFeeForParcelNumber = $this->getMonthlyFeeForPeriod($data);
            $monthD = $data->month;
            $i = 0; 
            while($monthlyFeeForParcelNumber[$i][0] < $monthD ) 
            {
                $i++;  
            }
            $parcelNumber = $monthlyFeeForParcelNumber[$i][0];
            // Insert Invoice 
            if($keepGoing)
            {
                $busLearningPeriod        = $MIOLO->getBusiness('academic', 'BusLearningPeriod');

                $invoice->personId        = $contractData->personId;
                $invoice->accountSchemeId = $data->accountSchemeId;
                $invoice->costCenterId    = $data->costCenterId;
                $invoice->courseId        = $data->courseId;
                $invoice->courseVersion   = $data->courseVersion; 
                $invoice->unitId          = $contractData->unitId;
                $invoice->parcelNumber    = $parcelNumber;
                $invoice->maturityDate    = $data->maturityDate;
                $invoice->value           = 0;
                $invoice->policyId        = $learningData->policyId;
                $invoice->bankInvoiceId   = NULL; 
                $invoice->automaticDebit  = $automaticDebit;
                $invoice->comments        = '-';
                $invoice->incomeSourceId  = INCOME_SOURCE_ID;
                $invoice->bankAccountId   = $busLearningPeriod->getLearningPeriodBankAccount($data->learningPeriodId);;
                $invoice->bankContractId  = $busLearningPeriod->getLearningPeriodBankContract($data->learningPeriodId);;
                $mudule = MIOLO::getCurrentModule();
               
                //connect and insert data
                $invoiceIdClosedIncomeForecast  = $this->insertReceivableInvoice($invoice);
                if (strlen ($invoiceIdClosedIncomeForecast) == 0 || $invoiceIdClosedIncomeForecast == null)
                {
                     $keepGoing = false;
            
                }

            }

            // Do inserts income forecast in Entry
            if ($keepGoing)
            {
                $i = 0;
                while ( $incomeForecastIds[$i][0] )
                {

                    $income = $this->getIncomeForecast($incomeForecastIds[$i][0]);
                    $income->invoiceId   = $invoiceIdClosedIncomeForecast;
                    $income->entryDate   = $actualDate;
                    $income->isAccounted = DB_FALSE;
                    if ( $income->value !== null )
                    {
//                        $business = $MIOLO->getBusiness('finance', 'BusEntry');
                        $res      = $this->insertEntry($income);
                    
                        if ($res == false)
                        {
                            $keepGoing == false;
                        }
                    }
                   
                   $i++;
                }
                                          
            }
            
            if ($keepGoing)
            {
                $sql = ' SELECT balance(?) ';
                $balanceValue = $this->db->query(SAGU::prepare($sql, $invoiceIdClosedIncomeForecast) );
                $res      = $this->updateInvoiceValue($balanceValue[0][0], $invoiceIdClosedIncomeForecast);
                 
            }
            
            $this->db->execute(($keepGoing ? 'COMMIT' : 'ROLLBACK'));
            
            if ($keepGoing)
            {
                $opts = array('function'=>'closed_yes',
                              'event'=>'closed');
                return true; 
            }
            else
            {
                $opts = array('function'=>'closed_no',
                              'event'=>'closed');
                return false; 
            }
            
    }
   /**
    *
    * Mark a incomeForecast as supressed
    *
    * @param: #$incomeForecastId (int): Primary key for income forecast
    * 
    * @return: True if runs otherwise false
    *
    */
    function setIsSupressed($incomeForecastId)
    {
        $sql = ' UPDATE finIncomeForecast
                    SET isSupressed = ?
                  WHERE incomeForecastId = ? ';
        
        $args = array(DB_TRUE, $incomeForecastId);
        $return = $this->db->execute($sql, $args);
        return $return;
    }

   /**
    *
    * Process incentives in income forecasts
    * 
    * @param: $data (object): Object containing necessary data to make this process
    *
    * @return (object): Object containing information about process
    *
    */
    public function processIncentives($data)
    {   
        $MIOLO  = MIOLO::getInstance();
        $module = 'finance';
        $this->db->execute('BEGIN TRANSACTION');

        $sql = '     SELECT A.incentiveId,
                            A.valueIsPercent,
                            A.value,
                            A.costCenterId,
                            B.operationId,
                            C.description
                       FROM finIncentive A
                 INNER JOIN finIncentiveType B
                      USING (incentiveTypeId)
                 INNER JOIN finOperation C
                      USING (operationId)
                      WHERE incentiveId = ? ';
        $args = array($data->incentiveId);
        $incentiveData = $this->db->query(SAGU::prepare($sql, $args));
        if (is_array($incentiveData[0]))
        {
            $incentiveData = $incentiveData[0];
        }
        else
        {
            $MIOLO->information(_M('No incentive information found', $module), 'javascript:window.close();');
        }

        // Obtain incomeForecast date period
        $sql = ' SELECT TO_CHAR(beginDate, \''.MASK_DATE.'\'),
                        TO_CHAR(endDate, \''.MASK_DATE.'\')
                   FROM acdLearningPeriod
                  WHERE learningPeriodId = ? ';

        $args = array($data->learningPeriodId);
        $learningPeriodData = $this->db->query(SAGU::prepare($sql, $args));

        if (is_array($learningPeriodData[0]))
        {
            $businessDefaultOperations = $MIOLO->getBusiness($module, 'BusDefaultOperations');
            $defaultOperations  = $businessDefaultOperations->getDefaultOperations();
            $operationsToFilter = array($defaultOperations->enrollOperation,
                                        $defaultOperations->addCurricularComponentOperation,
                                        $defaultOperations->cancelCurricularComponentOperation);

            if (defined('CURRICULAR_COMPONENT_DISCOUNT'))
            {
                $ccd = explode(',', CURRICULAR_COMPONENT_DISCOUNT);
                $operationsToFilter = array_unique(array_merge($operationsToFilter, $ccd));
            }

            // Obtain the income forecasts relative for that contract and the
            // specific learningPeriod
            $learningPeriodData = $learningPeriodData[0];
            $sql = '     SELECT TO_CHAR(maturityDate, \'mm\') as month,
                                TO_CHAR(maturityDate, \'yyyy\') as year,
                                accountSchemeId,
                                costCenterId,
                                sum(CASE WHEN B.operationTypeId = \'D\' 
                                         THEN A.value
                                         ELSE A.value*-1
                                     END) as balance
                           FROM finIncomeForecast A
                     INNER JOIN finOperation B
                          USING (operationId)
                          WHERE A.maturityDate
                        BETWEEN TO_DATE(?, \''.MASK_DATE.'\') 
                            AND TO_DATE(?, \''.MASK_DATE.'\') 
                            AND A.contractId = ? 
                            AND A.operationId IN ('.implode(',', $operationsToFilter).')
                       GROUP BY 1,
                                2,
                                3,
                                4
                       ORDER BY 2,
                                1 ';

            $args = array($learningPeriodData[0],
                          $learningPeriodData[1],
                          $data->contractId);

            // Obtain the balance relative to enroll operations and institution discounts
            // to apply the discount
            $incomeForecastData = $this->db->query(SAGU::prepare($sql, $args));
            if (is_array($incomeForecastData[0]))
            {
                // Get the maturityDay from contract
                $sql = ' SELECT maturityDay
                           FROM acdContract
                          WHERE contractId = ? ';
                
                $args = array($data->contractId);
                
                $contractData = $this->db->query(SAGU::prepare($sql, $args));
                if (is_array($contractData[0]))
                {
                    if (strlen((string)$contractData[0][0])>0)
                    {
                        $maturityDay = $contractData[0][0];
                    }
                    else
                    {
                        $MIOLO->information(_M('Maturity day must need filled for contract @1', $module, $data->contractId), 'javascript:window.close()');
                        $keepGoing = false;
                    } 
                }

                $periodData[0] = date('m');
                $periodData[1] = date('Y');
                $toProcess = false;

                // For each income forecast verify the period getting an analysis
                // about maturity period, if maturity period is before
                // the actual date then process the income forecast
                // else ignore it.
                foreach ($incomeForecastData as $icd)
                {
                    // Verify if the incentive has value or percentage 
                    // calculation mode
                    // TRUE -> Percentage
                    if ($incentiveData[1] == DB_TRUE)
                    {
                        $value = SAGU::CalcNumber($icd[4].'*('.$incentiveData[2].'/100)');
                    }
                    // FALSE -> Full value
                    else
                    {
                        if (SAGU::calcNumber($incentiveData[2].'-'.$icd[4])>=0)
                        {
                            $value = SAGU::formatNumber($incentiveData[2]);
                        }
                        else
                        {
                            $incomeForecast->warning = _M('Incentive value greater than enroll balance', $module);
                            $value = SAGU::formatNumber($icd[4]);
                        }
                    }

                    $incomeForecast->contractId      = $data->contractId;
                    $incomeForecast->operationId     = $incentiveData[4];
                    $incomeForecast->accountSchemeId = $icd[2];
                    $incomeForecast->costCenterId    = strlen((string)$incentiveData[3])>0 ? $incentiveData[3] : $icd[3];
                    $incomeForecast->value           = $value;
                    $incomeForecast->comments        = defined('MESSAGE_TO_INCENTIVE_PROCESS_IN_INCOME_FORECAST') ? MESSAGE_TO_INCENTIVE_PROCESS_IN_INCOME_FORECAST : '';
                    $incomeForecast->maturityDate    = SAGU::toDefaultDate($maturityDay.'/'.$icd[0].'/'.$icd[1], 'dd/mm/yyyy'); 
                    $incomeForecast->isProcessed     = DB_FALSE;
                    $incomeForecast->isGenerated     = DB_FALSE;
                    $incomeForecast->operationDescription = $incentiveData[5];
                    if ($icd[1] == $periodData[1])
                    {
                        if ($icd[0] > $periodData[0])
                        {
                            $incomeForecasts[] = clone($incomeForecast);
                            unset($incomeForecast);
                        }
                        else
                        {
                            $incomeForecast->reason = new MLabel(_M('Period accounted', $module), 'red');
                            $nincomeForecasts[] = clone($incomeForecast);
                            unset($incomeForecast);

                        }
                    }
                    elseif ($icd[1]>$periodData[1])
                    {
                        $incomeForecasts[] = clone(incomeForecast);
                        unset($incomeForecast);
                    }
                }
                if (is_array($incomeForecasts))
                {
                    $keepGoing = true;
                    foreach ($incomeForecasts as $key => $ic)
                    {
                        $incomeForecastId = $this->insertIncomeForecast($ic);
                        if ($incomeForecastId !== false)
                        {
                            $incomeForecasts[$key]->incomeForecastId = $incomeForecastId;
                        }
                        else
                        {
                            $keepGoing = false;
                        }
                    }
                }
                else
                {
                    $MIOLO->information(_M('No income forecasts found to process', $module), 'javascript:window.close();');
                }
            }
            else
            {
                $MIOLO->information(_M('No income forecasts found to process', $module), 'javascript:window.close();');
            }
        }
        
else
        {
            $MIOLO->information(_M('Sorry, is not a valid period', $module), 'javascript:window.close();');
        }
        $this->db->execute(($keepGoing === true) ? 'COMMIT' : 'ROLLBACK');

        // Income forecasts procssed
        if (is_array($incomeForecasts))
        {
            foreach ($incomeForecasts as $key => $ic)
            {
                $processed[$key] = array($ic->incomeForecastId,
                                         $ic->costCenterId,
                                         $ic->operationId.' - '.$ic->operationDescription,
                                         $ic->maturityDate,
                                         SAGU::formatNumber($ic->value));

            }
            $statisticsData->processed = $processed;
        }
        // Income forecasts not processed to show in tableraw
        if (is_array($nincomeForecasts))
        {
            foreach ($nincomeForecasts as $key => $ic)
            {
                $nprocessed[$key] = array($ic->incomeForecastId,
                                          $ic->costCenterId,
                                          $ic->operationId.' - '.$ic->operationDescription,
                                          $ic->maturityDate,
                                          SAGU::formatNumber($ic->value),
                                          $ic->reason);

            }
            $statisticsData->notProcessed = $nprocessed;
        }
        $statisticsData->status = $keepGoing;
        return $statisticsData;
    }
}
?>
