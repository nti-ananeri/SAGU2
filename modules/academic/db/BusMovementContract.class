<?php
/**
 *
 * This file handles the connection and actions for acdMovementContract table
 *
 * @author Jamiel Spezia [jamiel@solis.coop.br]
 *
 * $version: $Id$
 *
 * \b Maintainers \n
 * Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 * Daniel Afonso Heisler [daniel@solis.coop.br]
 * Jamiel Spezia [jamiel@solis.coop.br]
 * William Prigol Lopes [william@solis.coop.br]
 * 
 * @since
 * Class created on 30/08/2005
 *
 * \b @organization \n
 * SOLIS - Cooperativa de Soluções Livres \n
 * The Sagu2 development team
 *
 * \b Copyleft \n
 * Copyleft (L) 2005 - SOLIS - Cooperativa de Soluções Livres \n
 *
 * \b License \n
 * Licensed under GPL (for further details read the COPYING file or http://www.gnu.org/copyleft/gpl.html )
 *
 * \b History \n
 * See history in CVS repository: http://sagu.solis.coop.br   
 *
 **/

/**
 * Class to manipulate the acdMovementContract table
 **/
class BusinessAcademicBusMovementContract extends Business
{
    public $db;
    
    /**
     * Class constructor
     **/
    public function BusinessAcademicBusMovementContract()
    {
        $this->db = $this->getDatabase();
    }
    
    /**
     * Make a connection to the database
     * 
     * @param $module (string): The module whose database we should connect. If null, the actual module database is connected.
     *
     * @return (object): A MIOLO Database connection
     **/
    public function getDatabase($module = null)
    {
        $MIOLO = MIOLO::getInstance();
        $MIOLO->getClass('basic','sagu');
        $module = is_null($module) ? 'academic' : $module;

        return $MIOLO->getDatabase($module);
    }

    /**
     * List all records from the table handled by the class
     *
     * @param: None
     *
     * @returns (array): Return an array with the entire table
     *
     **/
    public function listMovementContract()
    {
        return 'Not implemented';
    }
    
    /**
     * Return a specific record from the database
     *
     * @param $contractId (integer): Primary key of the record to be retrieved
     * @param $stateContractId (integer): Primary key of the record to be retrieved
     * @param $stateTime (timestamp): Primary key of the record to be retrieved
     *
     * @return (object): Return an object of the type handled by the class
     *
     **/
    public function getMovementContract($contractId, $stateContractId, $stateTime)
    {
        $sql = 'SELECT stateContractId,
                       reasonId,
                       TO_CHAR(stateTime,\'' . MASK_TIMESTAMP . '\'),
                       learningPeriodId,
                       userName,
                       TO_CHAR(dateTime,\'' . MASK_TIMESTAMP . '\'),
                       ipAddress
                  FROM acdMovementContract A
                 WHERE A.contractId      = ?
                   AND A.stateContractId = ?
                   AND A.stateTime       = TO_TIMESTAMP(?,\'' . MASK_TIMESTAMP . '\')';

        $db     = $this->getDatabase();

        $pk = array($contractId,
                    $stateContractId,
                    $stateTime );

        $result = $this->db->query(SAGU::prepare($sql, $pk));
        //$db->close();

        $movementContract = new acdMovementContract();

        list ( $movementContract->stateContractId, 
               $movementContract->reasonId,
               $movementContract->stateTime,
               $movementContract->learningPeriodId,
               $movementContract->userName,
               $movementContract->dateTime,
               $movementContract->ipAddress ) = $result[0];

        return $movementContract; 
    }
    
    /**
     * Return the last record for a movement contract by contract
     *
     * @param $contractId (integer): Primary key of the record to be retrieved
     *
     * @return (object): Return an object of the type handled by the class
     *
     **/
    public function getLastMovementContract($contractId)
    {
        $sql = 'SELECT reasonId,
                       TO_CHAR(stateTime,\'' . MASK_TIMESTAMP . '\'),
                       learningPeriodId
                  FROM acdMovementContract A
                 WHERE A.contractId = ?
              ORDER BY stateTime DESC LIMIT 1';

        $db     = $this->getDatabase();

        $pk = array( $contractId );

        $result = $this->db->query(SAGU::prepare($sql, $pk));
        //$db->close();

        $movementContract = new acdMovementContract();

        list ( $movementContract->reasonId,
               $movementContract->stateTime,
               $movementContract->learningPeriodId ) = $result[0];

        return $movementContract; 
    }



    public function getFirstMovementContractDiploma($contractId)
    {
        $sql = 'SELECT B.description,
                       TO_CHAR(MIN(stateTime),\'' . MASK_TIMESTAMP . '\')
                  FROM acdMovementContract A
            INNER JOIN acdStateContract B
                    ON (B.stateContractId = A.stateContractId)
                 WHERE A.contractId = ? 
              GROUP BY B.description';

        $db     = $this->getDatabase();

        $pk = array( $contractId );

        $result = $this->db->query(SAGU::prepare($sql, $pk));

        return $result; 
    }

    /**
     * Return the first record for a movement contract by contract
     *
     * @param $contractId (integer): Primary key of the record to be retrieved
     *
     * @return (object): Return an object of the type handled by the class
     *
     **/
    public function getFirstMovementContract($contractId)
    {
        $sql = 'SELECT A.stateContractId,
                       A.reasonId
                  FROM acdMovementContract A
                 WHERE A.contractId = ?
              ORDER BY A.stateTime';

        $db     = $this->getDatabase();

        $result = $this->db->query(SAGU::prepare($sql, $contractId));
        //$db->close();

        $movementContract = new acdMovementContract();

        list ( $movementContract->stateContractId,
               $movementContract->reasonId ) = $result[0];

        return $movementContract; 
    }
   
    /**
     * Do a search on the database table handled by the class
     *
     * @param $filters (object): Search filters
     *
     * @return (array): An array containing the search results
     **/
    public function searchMovementContract($filters)
    {
        $sql = 'SELECT A.contractId,
                       A.stateContractId,
                       B.description,
                       A.reasonId,
                       C.description,
                       TO_CHAR(A.stateTime,\'' . MASK_TIMESTAMP . '\'),
                       A.learningPeriodId,
                       d.description
                  FROM acdMovementContract A
             LEFT JOIN acdStateContract B
                    ON ( A.stateContractId = B.stateContractId )
             LEFT JOIN acdReason C
                    ON ( A.reasonId = C.reasonId )
             LEFT JOIN acdLearningPeriod D
                    ON ( A.learningPeriodId = D.learningPeriodId ) 
            INNER JOIN acdContract E
                    ON ( A.contractId = E.contractId ) ';

        if ( strlen((string)$filters->personId) > 0 )
        {
            $where .= ' AND E.personId = ?';
            $args[] = $filters->personId;
        }
        if ( strlen((string)$filters->contractId) > 0 )
        {
            $where .= ' AND A.contractId = ?';
            $args[] = $filters->contractId;
        }
        if ( strlen((string)$filters->stateContractId) > 0 )
        {
            $where .= ' AND A.stateContractId = ?';
            $args[] = $filters->stateContractId;
        }
        if ( strlen((string)$filters->reasonId) > 0 )
        {
            $where .= ' AND A.reasonId = ?';
            $args[] = $filters->reasonId;
        }
        if ( strlen((string)$filters->stateTime) > 0 )
        {
            $where .= ' AND A.stateTime = TO_TIMESTAMP(?,\'' . MASK_TIMESTAMP. '\')';
            $args[] = $filters->stateTime;
        }
        if ( strlen((string)$filters->learningPeriodId) > 0 )
        {
            $where .= ' AND A.learningPeriodId = ?';
            $args[] = $filters->learningPeriodId;
        }
        if ( strlen((string)$filters->periodId) > 0 )
        {
            $where .= ' AND (D.periodId = ? AND A.stateTime BETWEEN D.beginDate AND D.endDate) ';
            $args[] = $filters->periodId;
        }

        unset($result);
        if ( strlen((string)$where) > 0 )
        {
            $sql .= ' WHERE ' . substr($where, 4) . '
                   ORDER BY A.contractId, A.stateTime DESC';

            $db = $this->getDatabase();
            $result = $this->db->query(SAGU::prepare($sql, $args));
        }

        return $result;
    }

    /**
     * Insert a new record
     *
     * @param $data (object): An object of the type handled by the class
     *
     * @return True if succed, otherwise False
     *
     **/
    public function insertMovementContract($data)
    {
        $sql = 'INSERT INTO acdMovementContract
                            (contractId,
                             stateContractId,
                             reasonId,
                             stateTime,
                             learningPeriodId)
                     VALUES (?,
                             ?,
                             ?,
                             TO_TIMESTAMP(?, \'' . MASK_TIMESTAMP . '\'),
                             ?)';

        $db     = $this->getDatabase();

        $args = array($data->contractId,
                      $data->stateContractId,
                      $data->reasonId,
                      $data->stateTime,
                      $data->learningPeriodId);

        $result = $this->db->execute(SAGU::prepare($sql, $args));
        //$db->close();

        return $result;
    }

    /**
     * Update data from a specific record
     *
     * @param $data (object): Data which will replace the old record data
     *
     * @return (boolean): True if succeed, otherwise False
     *
     **/
    public function updateMovementContract($data)
    {
        $sql = 'UPDATE acdMovementContract
                   SET reasonId             = ?,
                       learningPeriodId     = ?
                 WHERE contractId           = ? 
                   AND stateContractId      = ?
                   AND stateTime            = TO_TIMESTAMP(?, \'' . MASK_TIMESTAMP . '\')';

        $args = array( $data->reasonId,
                       $data->learningPeriodId,
                       $data->contractId,
                       $data->stateContractId,
                       $data->stateTime );


        $db   = $this->getDatabase();
        $sqls = SAGU::prepare($sql, $args);

        for ( $i=0; $i<count($sqls); $i++ )
        {
            $result = $this->db->execute($sqls[$i]);
        }

        //$db->close();

        return $result;
    }
    
    /**
     * Update the statetime from a specific record
     *
     * @param $data (object): Data which will replace the old record data
     *
     * @return (boolean): True if succeed, otherwise False
     *
     **/
    public function updateStateTimeMovementContract($data)
    {
        $sql = 'UPDATE acdMovementContract
                   SET stateTime            = TO_TIMESTAMP(?,\'' . MASK_TIMESTAMP . '\')
                 WHERE contractId           = ? 
                   AND stateContractId      = ?
                   AND stateTime            = ?';

        $args = array( $data->stateTimeNew,
                       $data->contractId,
                       $data->stateContractId,
                       $data->stateTimeOld );


        $db   = $this->getDatabase();
        $sqls = SAGU::prepare($sql, $args);

        for ( $i=0; $i<count($sqls); $i++ )
        {
            $result = $this->db->execute($sqls[$i]);
        }

        //$db->close();

        return $result;
    }

    /**
     * Delete a record
     *
     * @param $contractId (string): Primary key for deletion
     * @param $stateContractId (string): Primary key for deletion
     *
     * @return (boolean): True if succeed, otherwise False
     *
     **/
    public function deleteMovementContract($contractId, $stateContractId, $stateTime)
    {
        $sql = 'DELETE FROM acdMovementContract
                      WHERE contractId      = ?
                        AND stateContractId = ?
                        AND stateTime       = TO_TIMESTAMP(?,\'' . MASK_TIMESTAMP . '\')';

        $db     = $this->getDatabase();
        $pk = array($contractId,
                    $stateContractId,
                    $stateTime );

        $result = $this->db->execute(SAGU::prepare($sql, $pk));
        //$db->close();

        return $result;
    }

    public function getMovementContractSummary($contractId)
    {
        $sql = 'SELECT TO_CHAR(A.stateTime, \'' . MASK_TIMESTAMP . '\'), 
                       B.description,
                       A.stateContractId 
                  FROM acdMovementContract A 
            INNER JOIN acdStateContract B 
                    ON (A.stateContractId = B.stateContractId) 
                 WHERE A.contractId = ? 
              ORDER BY A.stateTime DESC';

        $db     = $this->getDatabase();
        $args   = array($contractId);
        $result = $this->db->query(SAGU::prepare($sql, $args));
        
        return $result;
    }

    /**
     * Check wether the proposed contract movement is allowed for the
     * specified contract at the specified timestamp. A check for consistent
     * insert of the state contract id and reason id pairs is also done.
     *
     * @param $contractId (integer): Contract on which the contract movement will be inserted
     * @param $stateContractId (integer): State to be used for the movement
     * @param $stateTime (timestamp): Timestamp at which the movement will be inserted
     *
     * @return (boolean): True if the movement is allowed. Otherwise, false.
     *
     **/
    public function movementContractInsertionAllowed($contractId, $stateContractId, $stateTime, $reasonId)
    {
        $MIOLO = MIOLO::getInstance();
        $module = MIOLO::getCurrentModule();

        // primeira movimentacao posterior a que se esta
        // tentando inserir
        $sql = '  SELECT stateContractId
                    FROM acdMovementContract
                   WHERE contractId = ?
                     AND stateTime > TO_TIMESTAMP(?, \'' . MASK_TIMESTAMP . '\')
                ORDER BY stateTime ASC
                   LIMIT 1';

        $args   = array($contractId, $stateTime);
        $nextMovement = $this->db->query(SAGU::prepare($sql, $args));

        // primeira movimentacao anterior a que se esta
        // tentando inserir
        $sql = '  SELECT stateContractId
                    FROM acdMovementContract
                   WHERE contractId = ?
                     AND stateTime < TO_TIMESTAMP(?, \'' . MASK_TIMESTAMP . '\')
                ORDER BY stateTime DESC
                   LIMIT 1';

        $args   = array($contractId, $stateTime);
        $prevMovement = $this->db->query(SAGU::prepare($sql, $args));

        $businessStatesContract = $MIOLO->getBusiness($module,'BusStatesContract');
        $stateContract = $businessStatesContract->getStatesContract($stateContractId);

        $ok = true;
        $business = $MIOLO->getBusiness($module,'BusStateTransistion');

        // se a movimentacao exige um motivo
        if ( $stateContract->needsReason == DB_TRUE )
        {
            // verifica se foi informado um motivo
            $ok = (strlen((string)$reasonId) > 0);
            if ( ! $ok )
            {
                $this->addError(_M('This contract state requires a reason.', $module));
            }
            else
            {
                // checar se o par motivo (reasonId) e estado contratual (stateContractId)
                // eh valido
                $sql = 'SELECT COUNT(*)
                          FROM acdReason
                         WHERE reasonId = ?
                           AND stateContractId = ?';
                   
                $args = array ( $reasonId,
                                $stateContractId );
                        
                $result = $this->db->query(SAGU::prepare($sql, $args));

                // se o par motivo e estado contratual nao existe
                if ( $result[0][0] == 0 )
                {
                    $ok = false;
                    $this->addError(_M('This reason and state contract combination is not allowed.', $module));
                }
            }
        }

        if ( $ok )
        {
            // se nao ha movimentacoes
            if ( count($nextMovement) == 0 && count($prevMovement) == 0 )
            {
                // movimentacao a ser inserida deve ser de entrada
                $ok = ( $stateContract->inOutTransition == 'i' );
                if ( ! $ok )
                {
                    $this->addError(_M('The first contract movement must be of type "in".', $module));
                }
            }
            // se ha movimentacoes anteriores e posteriores
            elseif ( count($nextMovement) > 0 && count($prevMovement) > 0 )
            {
                // movimentacao a ser inserida deve ser de transicao
                $ok = ( $stateContract->inOutTransition == 't' );
                if ( ! $ok )
                {
                    $this->addError(_M('To insert a contract movement between two others, it must be of type "transition".', $module));
                }
                else
                {
                    // a movimentacao deve ser permitida
                    $stateTransistion = $business->getStateTransistion($stateContractId, $nextMovement[0][0]);
                    $ok = isset($stateTransistion->beginStateId);
                    if ( ! $ok )
                    {
                        $nextStateContract = $businessStatesContract->getStatesContract($nextMovement[0][0]);
                        $this->addError(_M('The state contract @1 doesn\'t allow the state contract @2 as next.', $module, $stateContract->stateContractId . ' - ' . $stateContract->description, $nextStateContract->stateContractId . ' - ' . $nextStateContract->description));
                    }
                    else 
                    {
                        $stateTransistion = $business->getStateTransistion($prevMovement[0][0], $stateContractId);
                        $ok = isset($stateTransistion->beginStateId);
                        if ( ! $ok )
                        {
                            $prevStateContract = $businessStatesContract->getStatesContract($prevMovement[0][0]);
                            $this->addError(_M('The state contract @1 doesn\'t allow the state contract @2 as previous.', $module, $stateContract->stateContractId . ' - ' . $stateContract->description, $prevStateContract->stateContractId . ' - ' . $prevStateContract->description));
                        }
                    }
                }
            }
            // se somente houver movimentacao posterior a que se esta tentando inserir
            elseif ( count($nextMovement) > 0 )
            {
                // movimentacao a ser inserida deve ser de entrada
                $ok = ( $stateContract->inOutTransition == 'i' );
                if ( ! $ok )
                {
                    $this->addError(_M('The first contract movement must be of type "in".', $module));
                }
                else 
                {
                    // a movimentacao deve ser possivel
                    $stateTransistion = $business->getStateTransistion($stateContractId, $nextMovement[0][0]);
                    $ok = isset($stateTransistion->beginStateId);
                    if ( ! $ok )
                    {
                        $nextStateContract = $businessStatesContract->getStatesContract($nextMovement[0][0]);
                        $this->addError(_M('The state contract @1 doesn\'t allow the state contract @2 as next.', $module, $stateContract->stateContractId . ' - ' . $stateContract->description, $nextStateContract->stateContractId . ' - ' . $nextStateContract->description));
                    }
                }
            }
            // se somente houver movimentacao anterior a que se esta tentando inserir
            elseif ( count($prevMovement) > 0 )
            {
                // movimentacao a ser inserida deve ser de transicao
                $ok = ( $stateContract->inOutTransition == 't' || $stateContract->inOutTransition == 'o' );
                if ( ! $ok )
                {
                    $this->addError(_M('The last contract movement must be of type "transition" or "out".', $module));
                }
                else
                {
                    // a movimentacao devera ser permitida
                    $stateTransistion = $business->getStateTransistion($prevMovement[0][0], $stateContractId);
                    $ok = isset($stateTransistion->beginStateId);
                    if ( ! $ok )
                    {
                        $prevStateContract = $businessStatesContract->getStatesContract($prevMovement[0][0]);
                        $this->addError(_M('The state contract @1 doesn\'t allow the state contract @2 as previous.', $module, $stateContract->stateContractId . ' - ' . $stateContract->description, $prevStateContract->stateContractId . ' - ' . $prevStateContract->description));
                    }
                }
            }
        }

        return $ok;
    }

    function closePupilInClass($contractId)
    {
        $sql = 'UPDATE acdClassPupil
                   SET endDate    = date(now())
                 WHERE contractId = ?';

        $result = $this->db->execute(SAGU::prepare($sql, $contractId));
        //$db->close();

        return $result;
    }
}

?>
