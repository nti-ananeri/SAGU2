<?php
/**
 *
 * This file handles the connection and actions for accAccountBalance table
 *
 * @author Daniel Afonso Heisler [daniel@solis.coop.br]
 *
 * $version: $Id$
 *
 * \b Maintainers \n
 * Armando Taffarel Neto [taffarel@solis.coopb.br]
 * Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 * Daniel Afonso Heisler [daniel@solis.coop.br]
 * Jamiel Spezia [jamiel@solis.coop.br]
 * William Prigol Lopes [william@solis.coop.br]
 * 
 * @since
 * Class created on 25/06/2006
 *
 * \b @organization \n
 * SOLIS - Cooperativa de Soluções Livres \n
 * The Sagu2 development team
 *
 * \b Copyleft \n
 * Copyleft (L) 2005 - SOLIS - Cooperativa de Soluções Livres \n
 *
 * \b License \n
 * Licensed under GPL (for further details read the COPYING file or http://www.gnu.org/copyleft/gpl.html )
 *
 * \b History \n
 * See history in CVS repository: http://sagu.solis.coop.br   
 *
 **/

/**
 * Class to manipulate the accAccountBalance table
 **/
class BusinessAccountancyBusAccountBalance extends MBusiness
{

    public $db;

    /**
     * Class constructor
     **/
    public function BusinessAccountancyBusAccountBalance()
    {
        $this->db = $this->getDatabase();
    }

    /**
     * Make a connection to the database
     * 
     * @param $module (string): The module whose database we should connect. If null, the actual module database is connected.
     *
     * @return (object): A MIOLO Database connection
     **/
    public function getDatabase($module = null)
    {
        $MIOLO  = MIOLO::getInstance();
        $MIOLO->getClass('basic', 'sagu');
        $module = is_null($module) ? 'accountancy' : $module;

        return $MIOLO->getDatabase($module);
    }

    /**
     * Get the last top date from accAccountBalance
     *
     * @param: None
     *
     * @returns (array): Return an array with the years
     *
     **/
    public function getLastDate()
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $sql = 'SELECT TO_CHAR((max(balanceDate) + 1)::date, \'' . MASK_DATE . '\')
                  FROM accAccountBalance';

        $result = $this->db->query(SAGU::prepare($sql, null));

        return $result[0][0];
    }

    /**
     * List all distinct top dates from accAccountBalance
     *
     * @param: None
     *
     * @returns (array): Return an array with the years
     *
     **/
    public function getTopDates()
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $sql = 'SELECT DISTINCT balanceDate,
                                TO_CHAR(balanceDate, \'' . MASK_DATE . '\')
                           FROM accAccountBalance
                       ORDER BY balanceDate ASC';

        $result = $this->db->query(SAGU::prepare($sql, null));

        return $result;
    }

    /**
     * List all distinct top dates from accAccountBalance from one date
     *
     * @param: balanceDate(date): filtered top date
     * @param: type(text): stored balance type: forecast, entry or all
     *
     * @returns (array): Return an array with respective data
     *
     **/
    public function getStoredBalance($balanceDate, $type=null)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        if ( strtoupper($type) == 'FORECAST' )
        {
            $par = ' AND A.source = \'P\' ';
        }
        elseif ( strtoupper($type) == 'ENTRY' )
        {
            $par = ' AND A.source = \'L\' ';
        }

        $sql = 'SELECT A.accountSchemeId,
                       A.courseId, 
                       getCourseName(A.courseId) as courseName, 
                       A.unitId,
                       A.source, 
                       C.description,
                       round(A.value,' . REAL_ROUND_VALUE . ')
                  FROM accCourseBalance A
             LEFT JOIN accAccountBalance D
                    ON (     A.accountSchemeId = D.accountSchemeId 
                         AND A.source          = D.source
                         AND A.balanceDate     = D.balanceDate )
             LEFT JOIN accCourseAccount B
                    ON (     A.courseId      = B.courseId
                         AND A.courseVersion = B.courseVersion
                         AND A.unitId        = B.unitId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE A.balanceDate = TO_DATE(?, \'' . MASK_DATE . '\')' . $par . '
              ORDER BY A.accountSchemeId,
                       A.courseId';

        $result = $this->db->query(SAGU::prepare($sql, $balanceDate));

        return $result;
    }

    /**
     * List all distinct top dates from accAccountBalance
     *
     * @param: balanceDate(date): filtered top date
     * @param: type(text): stored balance type: forecast, entry or all
     *
     * @returns (array): Return an array with respective data
     *
     **/
    public function getAllStoredBalance($balanceDate, $type=null)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        if ( strtoupper($type) == 'FORECAST' )
        {
            $par = ' AND A.source = \'P\' ';
        }
        elseif ( strtoupper($type) == 'ENTRY' )
        {
            $par = ' AND A.source = \'L\' ';
        }

        $sql = 'SELECT A.accountSchemeId,
                       A.courseId, 
                       getCourseName(A.courseId) as courseName, 
                       A.unitId,
                       A.source, 
                       C.description,
                       round(sum(A.value),' . REAL_ROUND_VALUE . ')
                  FROM accCourseBalance A
             LEFT JOIN accAccountBalance D
                    ON (     A.accountSchemeId = D.accountSchemeId 
                         AND A.source          = D.source
                         AND A.balanceDate     = D.balanceDate )
             LEFT JOIN accCourseAccount B
                    ON (     A.courseId      = B.courseId
                         AND A.courseVersion = B.courseVersion
                         AND A.unitId        = B.unitId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE A.balanceDate <= TO_DATE(?, \'' . MASK_DATE . '\')' . $par . '
                   AND A.value <> 0
              GROUP BY A.accountSchemeId,
                       A.courseId, 
                       courseName, 
                       A.unitId,
                       A.source, 
                       C.description
                HAVING sum(A.value) <> 0
              ORDER BY A.accountSchemeId,
                       A.courseId';

        $result = $this->db->query(SAGU::prepare($sql, $balanceDate));

        return $result;
    }

    /**
     * List all distinct top dates from accAccountBalance from onde date
     *
     * @param: balanceDate(date): filtered top date
     * @param: balanceDate(date): filtered account scheme code
     * @param: type(text): stored balance type: forecast, entry or all
     *
     * @returns (array): Return an array with the data
     *
     **/
    public function getAccountStoredBalance($balanceDate, $accountSchemeId=null, $type=null)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        if ( strtoupper($type) == 'FORECAST' )
        {
            $par = ' AND source = \'P\' ';
        }
        elseif ( strtoupper($type) == 'ENTRY' )
        {
            $par = ' AND source = \'L\' ';
        }

        if ( is_null($accountSchemeId) )
        {
            $sql = 'SELECT round(sum(value),' . REAL_ROUND_VALUE . ')
                      FROM accAccountBalance
                     WHERE balanceDate = TO_DATE(?, \'' . MASK_DATE . '\')' . $par;
            $args   = array($balanceDate);
        }
        else
        {
            $sql = 'SELECT round(sum(value),' . REAL_ROUND_VALUE . ')
                      FROM accAccountBalance
                     WHERE balanceDate = TO_DATE(?, \'' . MASK_DATE . '\')
                       AND accountSchemeId = ?' . $par;
            $args   = array($balanceDate, $accountSchemeId);
        }

        $result = $this->db->query(SAGU::prepare($sql, $args));

        $result = $result[0][0];

        return $result;
    }

    /**
     * List all distinct top dates from accAccountBalance
     *
     * @param: balanceDate(date): filtered top date
     * @param: accountSchemeId(text): filtered account scheme code
     * @param: type(text): stored balance type: forecast, entry or all
     *
     * @returns (array): Return an array with the data
     *
     **/
    public function getAllAccountStoredBalance($balanceDate, $accountSchemeId=null, $type=null)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        if ( strtoupper($type) == 'FORECAST' )
        {
            $par = ' AND source = \'P\' ';
        }
        elseif ( strtoupper($type) == 'ENTRY' )
        {
            $par = ' AND source = \'L\' ';
        }

        if ( is_null($accountSchemeId) )
        {
            $sql = 'SELECT round(sum(value),' . REAL_ROUND_VALUE . ')
                      FROM accAccountBalance
                     WHERE balanceDate <= TO_DATE(?, \'' . MASK_DATE . '\')' . $par;
            $args   = array($balanceDate);
        }
        else
        {
            $sql = 'SELECT round(sum(value),' . REAL_ROUND_VALUE . ')
                      FROM accAccountBalance
                     WHERE balanceDate <= TO_DATE(?, \'' . MASK_DATE . '\')
                       AND accountSchemeId = ?' . $par;
            $args   = array($balanceDate, $accountSchemeId);
        }

        $result = $this->db->query(SAGU::prepare($sql, $args));

        $result = $result[0][0];

        return $result;
    }

    /**
     * List all values from accountbalance + forecasts
     *
     * @param: initialDate(date): Begin date
     * @param: limitDate(date): End date
     *
     * @returns (array): Return an array with respective data
     *
     **/
    public function getForecasts($initialDate, $limitDate)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $sql = 'SELECT A.accountSchemeId,
                       A.courseId, 
                       getCourseName(A.courseId) as courseName, 
                       A.unitId,
                       A.source || \'_\',
                       C.description,
                       round(sum(A.value),' . REAL_ROUND_VALUE . ')
                  FROM accCourseBalance A
             LEFT JOIN accAccountBalance D
                    ON (     A.accountSchemeId = D.accountSchemeId 
                         AND A.source          = D.source
                         AND A.balanceDate     = D.balanceDate )
             LEFT JOIN accCourseAccount B
                    ON (     A.courseId      = B.courseId
                         AND A.courseVersion = B.courseVersion
                         AND A.unitId        = B.unitId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE A.balanceDate < TO_DATE(?, \'' . MASK_DATE . '\')
                   AND A.source = \'P\'
                   AND A.value <> 0
              GROUP BY A.accountSchemeId,
                       A.courseId, 
                       courseName, 
                       A.unitId,
                       A.source, 
                       C.description
                HAVING sum(A.value) <> 0
                 UNION
                SELECT A.accountSchemeId,
                       getContractCourseId(A.contractId) as courseId,
                       getCourseName(getContractCourseId(A.contractId)) as courseName, 
                       getContractUnitId(A.contractId) as unitId,
                       \'P\' as source,
                       C.description,
                       round(SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * A.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * A.value ) END ),' . REAL_ROUND_VALUE . ') as value
                  FROM finIncomeForecast A
            INNER JOIN finOperation B1
                    ON ( A.operationId = B1.operationId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE getContractCourseId(A.contractId) <> 0
                   AND A.recordDate IS NOT NULL
                   AND A.recordDate >= TO_DATE(?, \'' . MASK_DATE . '\')
                   AND A.recordDate <= TO_DATE(?, \'' . MASK_DATE . '\')
              GROUP BY A.accountSchemeId,
                       getContractCourseId(A.contractId),
                       courseName, 
                       getContractUnitId(A.contractId),
                       source,
                       C.description
                HAVING sum(A.value) <> 0
              ORDER BY 1';

        $args = array($initialDate, $initialDate, $limitDate);

        $result = $this->db->query(SAGU::prepare($sql, $args));

        return $result;
    }


    /**
     * List all values from accountbalance + entries + forecasts
     *
     * @param: initialDate(date): Begin date
     * @param: limitDate(date): End date
     *
     * @returns (array): Return an array with respective data
     *
     **/
    public function getForecastsAndInvoices($initialDate, $limitDate)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $sql = 'SELECT A.accountSchemeId,
                       A.courseId, 
                       getCourseName(A.courseId) as courseName, 
                       A.unitId,
                       A.source || \'_\', 
                       C.description,
                       round(sum(A.value),' . REAL_ROUND_VALUE . ')
                  FROM accCourseBalance A
             LEFT JOIN accAccountBalance D
                    ON (     A.accountSchemeId = D.accountSchemeId 
                         AND A.source          = D.source
                         AND A.balanceDate     = D.balanceDate )
             LEFT JOIN accCourseAccount B
                    ON (     A.courseId      = B.courseId
                         AND A.courseVersion = B.courseVersion
                         AND A.unitId        = B.unitId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE A.balanceDate < TO_DATE(?, \'' . MASK_DATE . '\')
                   AND A.value <> 0
              GROUP BY A.accountSchemeId,
                       A.courseId, 
                       courseName, 
                       A.unitId,
                       A.source, 
                       C.description
                HAVING sum(A.value) <> 0
                 UNION
                SELECT A.accountSchemeId,
                       getContractCourseId(A.contractId) as courseId,
                       getCourseName(getContractCourseId(A.contractId)) as courseName, 
                       getContractUnitId(A.contractId) as unitId,
                       \'P\' as source,
                       C.description,
                       round(SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * A.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * A.value ) END ),' . REAL_ROUND_VALUE . ') as value
                  FROM finIncomeForecast A
            INNER JOIN finOperation B1
                    ON ( A.operationId = B1.operationId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE getContractCourseId(A.contractId) <> 0
                   AND A.recordDate IS NOT NULL
                   AND A.recordDate >= TO_DATE(?, \'' . MASK_DATE . '\')
                   AND A.recordDate <= TO_DATE(?, \'' . MASK_DATE . '\')
              GROUP BY A.accountSchemeId,
                       getContractCourseId(A.contractId),
                       courseName, 
                       getContractUnitId(A.contractId),
                       source,
                       C.description
                HAVING sum(A.value) <> 0
                 UNION
                SELECT A.accountSchemeId,
                       A.courseId,
                       getCourseName(A.courseId) as courseName, 
                       A.unitId,
                       \'L\' as source,
                       C.description,
                       round(SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * B.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * B.value ) END ),' . REAL_ROUND_VALUE . ') as value
             FROM ONLY finInvoice A
            INNER JOIN finEntry B
                    ON ( A.invoiceId = B.invoiceId )
            INNER JOIN finOperation B1
                    ON ( B.operationId = B1.operationId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE A.courseId <> 0
                   AND B.entryDate >= TO_DATE(?, \'' . MASK_DATE . '\')
                   AND B.entryDate <= TO_DATE(?, \'' . MASK_DATE . '\')
              GROUP BY A.accountSchemeId,
                       A.courseId,
                       courseName, 
                       A.unitId,
                       source,
                       C.description
                HAVING sum(B.value) <> 0
              ORDER BY 1';

        $args = array($initialDate, $initialDate, $limitDate, $initialDate, $limitDate);

        $result = $this->db->query(SAGU::prepare($sql, $args));

        return $result;
    }

    /**
     * Get the sum of the values from forecasts and accountancy balances
     *
     * @param: initialDate(date): Begin date
     * @param: limitDate(date): End date
     * @param: accountSchemeId(text): filtered account scheme code
     *
     * @returns (array): Return an array with respective data
     *
     **/
    public function getForecastsBalance($initialDate, $limitDate, $accountSchemeId=null)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $args[] = $initialDate;

        $sql = 'SELECT round(sum(value),' . REAL_ROUND_VALUE . ') FROM (
                SELECT sum(A.value) as Value
                  FROM accCourseBalance A
                 WHERE A.balanceDate < TO_DATE(?, \'' . MASK_DATE . '\')
                   AND A.source = \'P\' ';

        if ( ! is_null($accountSchemeId) )
        {
            $sql .= ' AND A.accountSchemeId = ? ';
            $args[] = $accountSchemeId;
        }

        $sql .= ' UNION
                SELECT SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * A.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * A.value ) END ) as value
                  FROM finIncomeForecast A
            INNER JOIN finOperation B1
                    ON ( A.operationId = B1.operationId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE getContractCourseId(A.contractId) <> 0
                   AND A.recordDate IS NOT NULL
                   AND A.recordDate >= TO_DATE(?, \'' . MASK_DATE . '\')
                   AND A.recordDate <= TO_DATE(?, \'' . MASK_DATE . '\') ';

        $args[] = $initialDate;
        $args[] = $limitDate;

        if ( ! is_null($accountSchemeId) )
        {
            $sql .= ' AND A.accountSchemeId = ? ';
            $args[] = $accountSchemeId;
        }

        $sql .= ' ) as X';

        $result = $this->db->query(SAGU::prepare($sql, $args));

        return $result[0][0];
    }

    /**
     * Get the sum of the values from forecasts, entries and accountancy balances
     *
     * @param: initialDate(date): Begin date
     * @param: limitDate(date): End date
     * @param: accountSchemeId(text): filtered account scheme code
     *
     * @returns (array): Return an array with respective data
     *
     **/
    public function getForecastsAndInvoicesBalance($initialDate, $limitDate, $accountSchemeId=null)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $args[] = $initialDate;

        $sql = 'SELECT round(sum(value),' . REAL_ROUND_VALUE . ') FROM (
                SELECT sum(A.value) as Value
                  FROM accCourseBalance A
                 WHERE A.balanceDate < TO_DATE(?, \'' . MASK_DATE . '\') ';

        if ( ! is_null($accountSchemeId) )
        {
            $sql .= ' AND A.accountSchemeId = ? ';
            $args[] = $accountSchemeId;
        }

        $sql .= ' UNION
                SELECT SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * A.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * A.value ) END ) as value
                  FROM finIncomeForecast A
            INNER JOIN finOperation B1
                    ON ( A.operationId = B1.operationId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE getContractCourseId(A.contractId) <> 0
                   AND A.recordDate IS NOT NULL
                   AND A.recordDate >= TO_DATE(?, \'' . MASK_DATE . '\')
                   AND A.recordDate <= TO_DATE(?, \'' . MASK_DATE . '\') ';

        $args[] = $initialDate;
        $args[] = $limitDate;

        if ( ! is_null($accountSchemeId) )
        {
            $sql .= ' AND A.accountSchemeId = ? ';
            $args[] = $accountSchemeId;
        }

        $sql .= ' UNION
                SELECT SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * B.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * B.value ) END ) as value
             FROM ONLY finInvoice A
            INNER JOIN finEntry B
                    ON ( A.invoiceId = B.invoiceId )
            INNER JOIN finOperation B1
                    ON ( B.operationId = B1.operationId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE A.courseId <> 0
                   AND B.entryDate >= TO_DATE(?, \'' . MASK_DATE . '\')
                   AND B.entryDate <= TO_DATE(?, \'' . MASK_DATE . '\') ';

        $args[] = $initialDate;
        $args[] = $limitDate;

        if ( ! is_null($accountSchemeId) )
        {
            $sql .= ' AND A.accountSchemeId = ? ';
            $args[] = $accountSchemeId;
        }

        $sql .= ' ) as X';

        $result = $this->db->query(SAGU::prepare($sql, $args));

        return $result[0][0];
    }

    /**
     * Process to generate accountancy balances
     *
     * @param: initialDate(date): Begin date
     * @param: limitDate(date): End date
     *
     * @returns (bool): True if generate with success otherwise false
     *
     **/
    public function generateAccountancyBalance($initialDate, $limitDate)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $this->beginTransaction();

        $balanceDate = $limitDate;

        //cria a tabela temporaria
        $sql = 'CREATE TEMP TABLE tmpBalance (
                                  accountSchemeId VARCHAR(30) NOT NULL,
                                  source CHAR(1),
                                  value NUMERIC(14,4),
                                  courseId VARCHAR(10),
                                  courseVersion INTEGER,
                                  unitId INTEGER,
                                  personId INTEGER )';

        $this->db->execute($sql);

        //insere lancamentos
        $sql = 'INSERT INTO tmpBalance ( accountSchemeId, source, value, courseId, courseVersion, unitId, personId )
                SELECT A.accountSchemeId,
                       \'L\' as source,
                       SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * B.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * B.value ) 
END ) as value,
                       A.courseId,
                       A.courseVersion,
                       A.unitId,
                       A.personId
             FROM ONLY finInvoice A
            INNER JOIN finEntry B
                    ON ( A.invoiceId = B.invoiceId )
            INNER JOIN finOperation B1
                    ON ( B.operationId = B1.operationId )
                 WHERE A.courseId <> 0
                   AND B.entryDate >= TO_DATE(\'' . $initialDate . '\', \'' . MASK_DATE . '\')
                   AND B.entryDate <= TO_DATE(\'' . $limitDate . '\', \'' . MASK_DATE . '\')
              GROUP BY A.accountSchemeId,
                       source,
                       A.courseId,
                       A.courseVersion,
                       A.unitId,
                       A.personId';

        $this->db->execute($sql);

        //insere previsoes
        $sql = 'INSERT INTO tmpBalance ( accountSchemeId, source, value, courseId, courseVersion, unitId, personId )
                SELECT A.accountSchemeId,
                       \'P\' as source,
                       SUM( CASE WHEN B.operationTypeId = \'D\' THEN ( 1 * A.value ) 
                                 WHEN B.operationTypeId = \'C\' THEN ( -1 * A.value ) END ) as value,
                       getContractCourseId(A.contractId),
                       getContractCourseVersion(A.contractId),
                       getContractUnitId(A.contractId),
                       getContractPersonId(A.contractId)
                  FROM finIncomeForecast A
            INNER JOIN finOperation B
                    ON ( A.operationId = B.operationId )
                 WHERE getContractCourseId(A.contractId) <> 0
                   AND A.recordDate IS NOT NULL
                   AND A.recordDate >= TO_DATE(\'' . $initialDate . '\', \'' . MASK_DATE . '\')
                   AND A.recordDate <= TO_DATE(\'' . $limitDate . '\', \'' . MASK_DATE . '\')
              GROUP BY A.accountSchemeId,
                       source,
                       getContractCourseId(A.contractId),
                       getContractCourseVersion(A.contractId),
                       getContractUnitId(A.contractId),
                       getContractPersonId(A.contractId)';

        $this->db->execute($sql);

        //apaga saldos contábeis da data limite
        $sql = 'DELETE FROM accCourseBalance WHERE balanceDate = TO_DATE(\'' . $limitDate . '\', \'' . MASK_DATE . '\')';
        $this->db->execute($sql);

        $sql = 'DELETE FROM accAccountBalance WHERE balanceDate = TO_DATE(\'' . $limitDate . '\', \'' . MASK_DATE . '\')';
        $this->db->execute($sql);

        $sql = 'DELETE FROM accPersonBalance WHERE balanceDate = TO_DATE(\'' . $limitDate . '\', \'' . MASK_DATE . '\')';
        $this->db->execute($sql);

        $chave = 0;

        //consulta tabela temporária para insercao na accAccountBalance
        $sql = 'SELECT A.accountSchemeId,
                       A.source,
                       SUM(A.value) as value
             FROM ONLY tmpBalance A
                 WHERE A.value <> 0
              GROUP BY A.accountSchemeId,
                       A.source
              ORDER BY A.accountSchemeId';

        $result = $this->db->query($sql);

        if ( count($result) > 0 )
        {

            //percorre os saldos a serem inseridos
            foreach ( $result as $row )
            {
                list ( $accountSchemeId,
                       $source,
                       $value ) = $row;

                //insere os saldos totais dos cursos
                $sql = 'INSERT INTO accAccountBalance
                                    (accountSchemeId,
                                     source,
                                     balanceDate,
                                     value)
                              VALUES (?, ?, TO_DATE(?, \'' . MASK_DATE . '\'), ?)';

                $args = array ( $accountSchemeId,
                                $source,
                                $balanceDate,
                                $value );

                $this->db->execute(SAGU::PREPARE($sql, $args));
            }
            $chave = 1;
        }

        //consulta tabela temporária para insercao na accCourseBalance
        $sql = 'SELECT A.accountSchemeId,
                       A.source,
                       SUM(A.value) as value,
                       A.courseId,
                       A.courseVersion,
                       A.unitId
             FROM ONLY tmpBalance A
                 WHERE A.value <> 0
              GROUP BY A.accountSchemeId,
                       A.source,
                       A.courseId,
                       A.courseVersion,
                       A.unitId
              ORDER BY A.accountSchemeId';

        $result = $this->db->query($sql);

        if ( count($result) > 0 && $chave == 1 )
        {

            //percorre os saldos a serem inseridos
            foreach ( $result as $row )
            {
                list ( $accountSchemeId,
                       $source,
                       $value,
                       $courseId,
                       $courseVersion,
                       $unitId ) = $row;

                //insere dados nos saldos parciais dos cursos
                $sql = 'INSERT INTO accCourseBalance
                                    (accountSchemeId,
                                     source,
                                     balanceDate,
                                     courseId,
                                     courseVersion,
                                     unitId,
                                     value)
                              VALUES (?, ?, TO_DATE(?, \'' . MASK_DATE . '\'), ?, ?, ?, ?)';

                $args = array ( $accountSchemeId,
                                $source,
                                $balanceDate,
                                $courseId,
                                $courseVersion,
                                $unitId,
                                $value );

                $this->db->execute(SAGU::PREPARE($sql, $args));
            }
        }

        //consulta tabela temporária para insercao na accPersonBalance
        $sql = 'SELECT A.accountSchemeId,
                       A.source,
                       SUM(A.value) as value,
                       A.courseId,
                       A.courseVersion,
                       A.unitId,
                       A.personId
             FROM ONLY tmpBalance A
                 WHERE A.value <> 0
              GROUP BY A.accountSchemeId,
                       A.source,
                       A.courseId,
                       A.courseVersion,
                       A.unitId,
                       A.personId
              ORDER BY A.accountSchemeId';

        $result = $this->db->query($sql);

        if ( count($result) > 0 && $chave == 1 )
        {

            //percorre os saldos a serem inseridos
            foreach ( $result as $row )
            {
                list ( $accountSchemeId,
                       $source,
                       $value,
                       $courseId,
                       $courseVersion,
                       $unitId,
                       $personId ) = $row;

                //insere os saldos totais dos alunos
                $sql = 'INSERT INTO accPersonBalance
                                    (accountSchemeId,
                                     personId,
                                     source,
                                     balanceDate,
                                     courseId,
                                     courseVersion,
                                     unitId,
                                     value)
                              VALUES (?, ?, ?, TO_DATE(?, \'' . MASK_DATE . '\'), ?, ?, ?, ?)';

                $args = array ( $accountSchemeId,
                                $personId,
                                $source,
                                $balanceDate,
                                $courseId,
                                $courseVersion,
                                $unitId,
                                $value );

                $this->db->execute(SAGU::PREPARE($sql, $args));

            }

        }

        return $this->finishTransaction();
    }

    public function beginTransaction()
    {
        return $this->db->execute('BEGIN TRANSACTION');
    }
    
    public function finishTransaction()
    {
        return $this->db->execute('COMMIT');
    }   

}
?>
